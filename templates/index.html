<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE ORACLE - Premium NBA Edge Finder</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container">
        <header>
            <h1>THE ORACLE</h1>
            <p class="subtitle">Sharp angles. No fluff. Pure edge. | Showing 70%+ probability props only</p>
            <nav class="top-nav">
                <a href="/yesterdays-bets" class="nav-link">Yesterday's Bets</a>
            </nav>
            <div class="stat-selector-container">
                <label for="statTypeSelect" class="stat-selector-label">üìä Stat Category:</label>
                <select id="statTypeSelect" onchange="changeStatType()" class="stat-selector">
                    <optgroup label="Individual Stats">
                        {% for key, stat in individual_stats.items() %}
                        <option value="{{ key }}" {% if current_stat_type == key %}selected{% endif %}>{{ stat.name }}</option>
                        {% endfor %}
                    </optgroup>
                    <optgroup label="Combination Stats">
                        {% for key, stat in combination_stats.items() %}
                        <option value="{{ key }}" {% if current_stat_type == key %}selected{% endif %}>{{ stat.name }} ({{ stat.abbreviation }})</option>
                        {% endfor %}
                    </optgroup>
                </select>
                <span class="stat-description" id="statDescription">{% if stat_categories and current_stat_type in stat_categories %}{{ stat_categories[current_stat_type].get('description', '') }}{% endif %}</span>
            </div>
            <p class="player-count">
                Loaded: <span id="totalPlayers" style="color: {% if projections|length > 0 %}#27ae60{% else %}#e74c3c{% endif %}; font-weight: bold;">{{ projections|length }}</span> relevant players | 
                Filtered to: <span id="filteredCount">{{ edges|length }}</span> props (70%+)
                <br><small style="color: #95a5a6; font-size: 0.85em;">Auto-loading players with hot streaks, trends, and role players in background...</small>
            </p>
        </header>

        {% if error %}
        <div class="error-message">
            <strong>Error:</strong> {{ error }}
        </div>
        {% endif %}

        <!-- Loading Indicator - shown when players are being loaded in background -->
        <div id="loadingIndicator" style="display: none; text-align: center; padding: 40px; background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 215, 0, 0.05)); border: 2px solid #ffd700; border-radius: 12px; margin: 20px 0;">
            <div style="font-size: 28px; color: #ffd700; margin-bottom: 15px;">‚è≥ Loading Players...</div>
            <div style="font-size: 16px; color: #fff; margin-bottom: 10px;">
                Background loading in progress. Please wait...
            </div>
            <div id="loadingProgress" style="font-size: 14px; color: #888;">
                Checking status...
            </div>
            <div style="margin-top: 15px;">
                <div style="width: 200px; height: 4px; background: #333; border-radius: 2px; margin: 0 auto; overflow: hidden;">
                    <div id="loadingBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ffd700, #ff8c00); animation: loadingPulse 2s ease-in-out infinite;"></div>
                </div>
            </div>
            <style>
                @keyframes loadingPulse {
                    0%, 100% { width: 30%; margin-left: 0%; }
                    50% { width: 50%; margin-left: 50%; }
                }
            </style>
        </div>

        <div class="controls">
            <button onclick="refreshData()" class="refresh-btn" id="refreshBtn">üîÑ Refresh Edges</button>
            <label class="auto-refresh-toggle">
                <input type="checkbox" id="autoRefresh" onchange="toggleAutoRefresh()">
                <span>Auto-refresh (60s)</span>
            </label>
            <button onclick="loadAllPlayers()" class="load-all-btn" id="loadAllBtn" title="Load ALL active NBA players (500+ players, takes 10-15 min)">üì• Load All Players</button>
            <button onclick="showLineManagement()" class="line-mgmt-btn" id="lineMgmtBtn">üìä Line Management</button>
            <button onclick="showParlayCalculator()" class="parlay-btn" id="parlayBtn">üé≤ Parlay Calculator</button>
            <label class="filter-toggle">
                <input type="checkbox" id="showAllToggle" onchange="toggleShowAll()">
                <span>Show All Edges (not just 70%+)</span>
            </label>
            <button onclick="showTacticalFilters()" class="filter-btn" id="filterBtn">üîç Tactical Filters</button>
        </div>

        <!-- Probability Tier Tabs -->
        <div class="probability-tabs">
            <span class="prob-label">Hit Rate Filter:</span>
            <button onclick="setMinProbability(60)" class="prob-tab" id="prob60">60%+</button>
            <button onclick="setMinProbability(70)" class="prob-tab active" id="prob70">70%+</button>
            <button onclick="setMinProbability(80)" class="prob-tab" id="prob80">80%+</button>
            <button onclick="setMinProbability(0)" class="prob-tab" id="probAll">All</button>
        </div>

        <!-- Tactical Filters Panel -->
        <div id="tacticalFiltersPanel" class="tactical-filters-panel" style="display: none;">
            <div class="filters-header">
                <h3>üîç Tactical Filters & Sorting</h3>
                <button onclick="hideTacticalFilters()" class="close-btn">‚úï</button>
            </div>
            
            <div class="filters-content">
                <div class="filters-section">
                    <h4>Sort By</h4>
                    <select id="sortSelect" onchange="applyFilters()" class="filter-select">
                        <option value="ev">Expected Value (EV)</option>
                        <option value="market_edge">Market Edge %</option>
                        <option value="probability">Probability</option>
                        <option value="grade">Matchup Grade</option>
                        <option value="edge">Edge Size</option>
                        <option value="kelly">Kelly Criterion</option>
                    </select>
                </div>
                
                <div class="filters-section">
                    <h4>Filters</h4>
                    <div class="filter-group">
                        <label>Min Probability: <span id="probValue">70</span>%</label>
                        <input type="range" id="minProbFilter" min="50" max="95" value="70" oninput="document.getElementById('probValue').textContent = this.value; applyFilters()">
                    </div>
                    <div class="filter-group">
                        <label>Min EV: $<span id="evValue">0</span></label>
                        <input type="range" id="minEvFilter" min="0" max="50" value="0" oninput="document.getElementById('evValue').textContent = this.value; applyFilters()">
                    </div>
                    <div class="filter-group">
                        <label>Min Market Edge: <span id="edgeValue">0</span>%</label>
                        <input type="range" id="minEdgeFilter" min="0" max="20" value="0" oninput="document.getElementById('edgeValue').textContent = this.value; applyFilters()">
                    </div>
                    <div class="filter-group">
                        <label>Min Grade:</label>
                        <select id="minGradeFilter" onchange="applyFilters()" class="filter-select">
                            <option value="">Any</option>
                            <option value="A+">A+</option>
                            <option value="A">A</option>
                            <option value="B+">B+</option>
                            <option value="B" selected>B</option>
                            <option value="C+">C+</option>
                            <option value="C">C</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>
                            <input type="checkbox" id="positiveEvOnly" onchange="applyFilters()">
                            Positive EV Only
                        </label>
                    </div>
                    <div class="filter-group">
                        <label>
                            <input type="checkbox" id="excludeInjuries" onchange="applyFilters()">
                            Exclude Injury Risks
                        </label>
                    </div>
                    <div class="filter-group">
                        <label>
                            <input type="checkbox" id="excludeRotation" onchange="applyFilters()">
                            Exclude Rotation Changes
                        </label>
                    </div>
                </div>
                
                <div class="filters-actions">
                    <button onclick="resetFilters()" class="reset-btn">Reset Filters</button>
                    <button onclick="hideTacticalFilters()" class="apply-btn">Apply</button>
                </div>
            </div>
        </div>


        <div class="status-bar">
            <span id="lastUpdate">Last updated: {{ "Now" if edges else "Never" }}</span>
            <span id="loadingIndicator" class="loading" style="display: none;">‚è≥ Updating...</span>
            <span id="dailyUpdateStatus" class="daily-status"></span>
        </div>

        <!-- Line Management Panel -->
        <div id="lineManagementPanel" class="line-management-panel" style="display: none;">
            <div class="panel-header">
                <h3>üìä Line Management</h3>
                <button onclick="hideLineManagement()" class="close-btn">‚úï</button>
            </div>
            
            <div class="panel-tabs">
                <button class="tab-btn active" onclick="showTab('line-changes')">Line Changes</button>
                <button class="tab-btn" onclick="showTab('chase-list')">Chase List</button>
                <button class="tab-btn" onclick="showTab('alt-lines')">Alt Lines</button>
                <button class="tab-btn" onclick="showTab('edit-lines')">Edit Lines</button>
            </div>

            <!-- Line Changes Tab -->
            <div id="tab-line-changes" class="tab-content active">
                <h4>Line Changes (Last 24h)</h4>
                <div id="lineChangesContainer"></div>
                <button onclick="loadLineChanges()" class="refresh-btn">üîÑ Refresh Changes</button>
            </div>

            <!-- Chase List Tab -->
            <div id="tab-chase-list" class="tab-content">
                <h4>Props to Chase</h4>
                <div id="chaseListContainer"></div>
                <button onclick="loadChaseList()" class="refresh-btn">üîÑ Refresh</button>
            </div>

            <!-- Alt Lines Tab -->
            <div id="tab-alt-lines" class="tab-content">
                <h4>Alternative Lines</h4>
                <div id="altLinesContainer"></div>
                <button onclick="loadAltLines()" class="refresh-btn">üîÑ Refresh</button>
            </div>

            <!-- Edit Lines Tab -->
            <div id="tab-edit-lines" class="tab-content">
                <h4>Edit Lines (Even After Send-Off)</h4>
                <div class="edit-lines-form">
                    <select id="editPlayerSelect" class="player-select">
                        <option value="">Select Player...</option>
                        {% for player in projections.keys() %}
                        <option value="{{ player }}">{{ player }}</option>
                        {% endfor %}
                    </select>
                    <input type="number" id="oldLineInput" step="0.5" placeholder="Old Line" class="line-input">
                    <input type="number" id="newLineInput" step="0.5" placeholder="New Line" class="line-input">
                    <button onclick="updateLine()" class="update-btn">Update Line</button>
                </div>
                <div id="editResult"></div>
            </div>
        </div>

        <div id="errorContainer"></div>

        <div id="edgesContainer">
            {% if edges %}
                <div class="edges-section">
                    <h2>70%+ PROBABILITY PROPS (<span id="edgeCount">{{ edges|length }}</span>)</h2>
                    <p class="section-subtitle">Only showing props with 70%+ hit probability from all active NBA players</p>
                    <div class="edges-grid" id="edgesGrid">
                        {% for edge in edges %}
                        <div class="oracle-card {{ edge.recommendation|lower }}">
                            <div class="oracle-header-row">
                                <div class="oracle-player">{{ edge.player }}</div>
                                {% if edge.confidence %}
                                <div class="confidence-meter">
                                    <div class="confidence-grade grade-{{ edge.confidence.grade|lower|replace('+', 'plus')|replace('-', 'minus') }}">
                                        {{ edge.confidence.grade }}
                                    </div>
                                    <div class="confidence-score">{{ edge.confidence.confidence_score|int }}</div>
                                </div>
                                <div class="risk-badge risk-{{ edge.confidence.risk_tier|lower }}">
                                    {{ edge.confidence.risk_tier }}
                                </div>
                                <div class="stake-badge">
                                    {{ edge.confidence.units }}u
                                </div>
                                {% elif edge.ev %}
                                <div class="ev-badge {% if edge.ev.is_positive_ev %}positive-ev{% else %}negative-ev{% endif %}">
                                    EV: ${{ edge.ev.ev|round(2) }}
                                </div>
                                {% endif %}
                            </div>
                            {% if edge.oracle %}
                            <div class="oracle-content">
                                <div class="oracle-line">
                                    <strong>The Line:</strong> {{ edge.oracle.verdict }}
                                </div>
                                <div class="oracle-sharp">
                                    <strong>The Sharp Angle:</strong> {{ edge.oracle.sharp_angle }}
                                </div>
                                <div class="oracle-key">
                                    <strong>Key Data Point:</strong> {{ edge.oracle.key_data }}
                                </div>
                                <div class="oracle-verdict">
                                    <strong>The Verdict:</strong> {{ edge.oracle.verdict }}
                                </div>
                                <div class="oracle-confidence">
                                    <strong>Confidence:</strong> 
                                    <span class="confidence-badge confidence-{{ edge.oracle.confidence|int }}">
                                        {{ edge.oracle.confidence }} Units
                                    </span>
                                </div>
                                <div class="oracle-risk">
                                    <strong>Risk Factor:</strong> {{ edge.oracle.risk_factor }}
                                </div>
                                {% if edge.advanced_metrics %}
                                <div class="advanced-metrics">
                                    <div class="metrics-row">
                                        <span>FG%:</span> <span>{{ edge.advanced_metrics.fg_pct }}%</span>
                                        <span>Pts/36:</span> <span>{{ edge.advanced_metrics.points_per_36 }}</span>
                                        <span>CV:</span> <span>{{ edge.advanced_metrics.consistency }}%</span>
                                    </div>
                                </div>
                                {% endif %}
                            </div>
                            {% else %}
                            <div class="edge-details">
                                <div class="stat-row">
                                    <span class="label">Line:</span>
                                    <span class="value">{{ edge.line }}</span>
                                </div>
                                <div class="stat-row">
                                    <span class="label">L5 Avg:</span>
                                    <span class="value">{{ edge.average }}</span>
                                </div>
                                <div class="recommendation">
                                    <strong>{{ edge.recommendation }}</strong>
                                </div>
                            </div>
                            {% endif %}
                            {% if edge.streak and edge.streak.active %}
                            <div class="streak-badge streak-{{ edge.streak.streak_type|lower }}">
                                üî• {{ edge.streak.streak_count }}-game {{ edge.streak.streak_type }} streak
                                {% if edge.streak.analytics and edge.streak.analytics.regression %}
                                <span class="regression-mini regression-{{ edge.streak.analytics.regression.risk_level }}">
                                    {{ edge.streak.analytics.regression.risk_level|upper }}
                                </span>
                                {% endif %}
                            </div>
                            {% if edge.streak.analytics and edge.streak.analytics.ev_adjustment %}
                            <div class="streak-ev-mini {% if edge.streak.analytics.ev_adjustment.adjustment_pct > 0 %}ev-positive{% else %}ev-negative{% endif %}">
                                Streak EV: {% if edge.streak.analytics.ev_adjustment.adjustment_pct > 0 %}+{% endif %}{{ edge.streak.analytics.ev_adjustment.adjustment_pct }}%
                            </div>
                            {% endif %}
                            {% endif %}
                                {% if edge.factors %}
                                <div class="performance-factors">
                                    <div class="factors-header" onclick="toggleFactors(this)">
                                        <span>üìä Performance Factors</span>
                                        <span class="toggle-icon">‚ñº</span>
                                    </div>
                                    <div class="factors-content" style="display: none;">
                                        {% if edge.factors.injury_risk %}
                                        <div class="factor-badge factor-warning">
                                            ‚ö†Ô∏è Injury Risk ({{ edge.factors.dnp_count }} DNP game{{ 's' if edge.factors.dnp_count != 1 else '' }})
                                        </div>
                                        {% endif %}
                                        {% if edge.factors.rotation_change %}
                                        <div class="factor-badge factor-info">
                                            üîÑ Rotation Change ({{ edge.factors.recent_minutes_avg }} min recent vs {{ edge.factors.older_minutes_avg }} min earlier)
                                        </div>
                                        {% endif %}
                                        <div class="factor-row">
                                            <span class="factor-label">Minutes Trend:</span>
                                            <span class="factor-value trend-{{ edge.factors.minutes_trend }}">
                                                {{ edge.factors.recent_minutes_avg }} min ({{ edge.factors.minutes_trend }})
                                            </span>
                                        </div>
                                        <div class="factor-row">
                                            <span class="factor-label">Performance Trend:</span>
                                            <span class="factor-value trend-{{ edge.factors.performance_trend }}">
                                                {{ edge.factors.performance_trend|title }}
                                            </span>
                                        </div>
                                        {% if edge.factors.shooting_efficiency %}
                                        <div class="factor-row">
                                            <span class="factor-label">FG% (L5):</span>
                                            <span class="factor-value">{{ edge.factors.shooting_efficiency }}%</span>
                                        </div>
                                        {% endif %}
                                    </div>
                                </div>
                                {% endif %}
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            {% else %}
                <div class="no-edges">
                    <p>No edges found with current threshold.</p>
                    <p class="info">Checked <span id="playerCount">{{ projections|length }}</span> players. Adjust threshold or check projections.</p>
                </div>
            {% endif %}
        </div>

        <!-- Parlay Calculator Modal -->
        <div id="parlayCalculatorModal" class="parlay-modal" style="display: none;">
            <div class="parlay-modal-content">
                <div class="parlay-modal-header">
                    <h2>üé≤ Parlay Calculator</h2>
                    <button onclick="hideParlayCalculator()" class="close-btn">‚úï</button>
                </div>
                <div class="parlay-calculator-body">
                    <!-- Parlay Size Tabs -->
                    <div class="parlay-tabs">
                        <button class="parlay-tab active" onclick="showParlayTab('2-man')">2-Man</button>
                        <button class="parlay-tab" onclick="showParlayTab('3-man')">3-Man</button>
                        <button class="parlay-tab" onclick="showParlayTab('4-man')">4-Man</button>
                        <button class="parlay-tab" onclick="showParlayTab('5-man')">5-Man</button>
                        <button class="parlay-tab" onclick="showParlayTab('6-man')">6-Man</button>
                    </div>
                    
                    <!-- 2-Man Parlays -->
                    <div id="parlay-2-man" class="parlay-tab-content active">
                        <h3>2-Man Parlays</h3>
                        <p class="parlay-desc">Best 2-leg combinations from high-probability props</p>
                        <div id="parlay2ManContainer" class="parlay-container">
                            <div class="loading-parlays">Loading recommendations...</div>
                        </div>
                    </div>
                    
                    <!-- 3-Man Parlays -->
                    <div id="parlay-3-man" class="parlay-tab-content">
                        <h3>3-Man Parlays</h3>
                        <p class="parlay-desc">Best 3-leg combinations for higher payouts</p>
                        <div id="parlay3ManContainer" class="parlay-container">
                            <div class="loading-parlays">Loading recommendations...</div>
                        </div>
                    </div>
                    
                    <!-- 4-Man Parlays -->
                    <div id="parlay-4-man" class="parlay-tab-content">
                        <h3>4-Man Parlays</h3>
                        <p class="parlay-desc">Best 4-leg combinations for big payouts</p>
                        <div id="parlay4ManContainer" class="parlay-container">
                            <div class="loading-parlays">Loading recommendations...</div>
                        </div>
                    </div>
                    
                    <!-- 5-Man Parlays -->
                    <div id="parlay-5-man" class="parlay-tab-content">
                        <h3>5-Man Parlays</h3>
                        <p class="parlay-desc">Best 5-leg combinations for massive payouts</p>
                        <div id="parlay5ManContainer" class="parlay-container">
                            <div class="loading-parlays">Loading recommendations...</div>
                        </div>
                    </div>
                    
                    <!-- 6-Man Parlays -->
                    <div id="parlay-6-man" class="parlay-tab-content">
                        <h3>6-Man Parlays</h3>
                        <p class="parlay-desc">Best 6-leg combinations for lottery-style payouts</p>
                        <div id="parlay6ManContainer" class="parlay-container">
                            <div class="loading-parlays">Loading recommendations...</div>
                        </div>
                    </div>
                    
                    <!-- Manual Calculator -->
                    <div class="manual-calculator">
                        <h3>Custom Parlay Builder</h3>
                        <div id="betsList"></div>
                        <button onclick="addBetRow()" class="add-bet-btn">+ Add Leg</button>
                        <button onclick="calculateCustomParlay()" class="calc-btn">Calculate</button>
                        <div class="calculator-results">
                            <div id="calculatorResults"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="highProbContainer">
            {% if high_prob_props %}
                <div class="high-prob-section">
                    <h2>üéØ HIGH PROBABILITY PROPS (70%+) - <span id="highProbCount">{{ high_prob_props|length }}</span></h2>
                    <p class="section-subtitle">PrizePicks/Underdog Format | Sorted by Probability</p>
                    <div class="high-prob-grid" id="highProbGrid">
                        {% for prop in high_prob_props %}
                        <div class="high-prob-card">
                            <div class="prob-header">
                                <div class="prob-badge">{{ prop.probability }}%</div>
                                <div class="prizepicks-display">{{ prop.prizepicks.display }}</div>
                            </div>
                            <div class="prob-details">
                                <div class="prob-reasoning">
                                    <strong>Reasoning:</strong> {{ prop.reasoning }}
                                </div>
                                <div class="prob-stats">
                                    <div class="stat-item">
                                        <span>L5 Average:</span>
                                        <span>{{ prop.edge.average }}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span>Line:</span>
                                        <span>{{ prop.edge.line }}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span>Edge:</span>
                                        <span class="edge-value">{{ prop.edge.difference }}pts</span>
                                    </div>
                                </div>
                                {% if prop.edge.streak and prop.edge.streak.active %}
                                <div class="streak-indicator">
                                    üî• {{ prop.edge.streak.streak_count }}-game {{ prop.edge.streak.streak_type }} streak
                                </div>
                                {% endif %}
                                {% if prop.beneficiary %}
                                <div class="matchup-indicator">
                                    ‚ö° vs {{ prop.beneficiary.opponent }}: {{ prop.beneficiary.mismatch }}
                                </div>
                                {% endif %}
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            {% endif %}
        </div>

        <div id="streaksContainer">
            {% if streaks %}
                <div class="streaks-section">
                    <h2>üî• Active Streaks (<span id="streakCount">{{ streaks|length }}</span>)</h2>
                    <p class="section-subtitle">Players consistently hitting OVER/UNDER for 2+ games - with regression analysis</p>
                    <div class="streaks-grid" id="streaksGrid">
                        {% for streak in streaks %}
                        <div class="streak-card streak-{{ streak.streak_type|lower }} {% if streak.streak_analytics and streak.streak_analytics.regression.risk_level == 'high' %}regression-high{% elif streak.streak_analytics and streak.streak_analytics.regression.risk_level == 'medium' %}regression-medium{% endif %}">
                            <div class="player-name">{{ streak.player }}</div>
                            <div class="streak-details">
                                <div class="stat-row">
                                    <span class="label">Line:</span>
                                    <span class="value">{{ streak.line }}</span>
                                </div>
                                {% if streak.average %}
                                <div class="stat-row">
                                    <span class="label">L5 Average:</span>
                                    <span class="value">{{ streak.average }}</span>
                                </div>
                                {% endif %}
                                <div class="streak-info">
                                    <div class="streak-badge-large streak-{{ streak.streak_type|lower }}">
                                        üî• {{ streak.streak_count }}-game {{ streak.streak_type }} streak
                                    </div>
                                </div>
                                
                                {% if streak.streak_analytics %}
                                <!-- Streak Analytics Panel -->
                                <div class="streak-analytics">
                                    <!-- Regression Warning -->
                                    {% if streak.streak_analytics.regression %}
                                    <div class="regression-indicator regression-{{ streak.streak_analytics.regression.risk_level }}">
                                        <div class="regression-header">
                                            {% if streak.streak_analytics.regression.risk_level == 'high' %}
                                            ‚ö†Ô∏è HIGH Regression Risk ({{ streak.streak_analytics.regression.risk_score }}%)
                                            {% elif streak.streak_analytics.regression.risk_level == 'medium' %}
                                            üü° Medium Regression Risk ({{ streak.streak_analytics.regression.risk_score }}%)
                                            {% else %}
                                            üü¢ Low Regression Risk
                                            {% endif %}
                                        </div>
                                        {% if streak.streak_analytics.regression.warnings %}
                                        <div class="regression-warnings">
                                            {% for warning in streak.streak_analytics.regression.warnings[:3] %}
                                            <div class="warning-item">‚Ä¢ {{ warning }}</div>
                                            {% endfor %}
                                        </div>
                                        {% endif %}
                                    </div>
                                    {% endif %}
                                    
                                    <!-- Historical Performance -->
                                    {% if streak.streak_analytics.historical_patterns %}
                                    <div class="historical-patterns">
                                        <div class="pattern-header">üìä Historical Streak Patterns</div>
                                        <div class="pattern-row">
                                            <span>Avg {{ streak.streak_type }} streak:</span>
                                            <span>{{ streak.streak_analytics.historical_patterns.avg_over_streak_length if streak.streak_type == 'OVER' else streak.streak_analytics.historical_patterns.avg_under_streak_length }} games</span>
                                        </div>
                                        <div class="pattern-row">
                                            <span>Max {{ streak.streak_type }} streak:</span>
                                            <span>{{ streak.streak_analytics.historical_patterns.max_over_streak if streak.streak_type == 'OVER' else streak.streak_analytics.historical_patterns.max_under_streak }} games</span>
                                        </div>
                                    </div>
                                    {% endif %}
                                    
                                    <!-- Line Correlation -->
                                    {% if streak.streak_analytics.line_correlation %}
                                    <div class="line-correlation">
                                        <div class="correlation-header">üìà Line Correlation</div>
                                        <div class="correlation-row">
                                            <span>Hit Rate ({{ streak.streak_type }}):</span>
                                            <span class="hit-rate">{{ streak.streak_analytics.line_correlation.hit_rate_over if streak.streak_type == 'OVER' else streak.streak_analytics.line_correlation.hit_rate_under }}%</span>
                                        </div>
                                        <div class="correlation-row">
                                            <span>Avg vs Line:</span>
                                            <span>{{ streak.streak_analytics.line_correlation.avg_vs_line|default(0) }}</span>
                                        </div>
                                        {% if streak.streak_analytics.line_correlation.line_accuracy != 'accurate' %}
                                        <div class="line-suggestion">
                                            üí° {{ streak.streak_analytics.line_correlation.line_suggestion|default('') }}
                                        </div>
                                        {% endif %}
                                    </div>
                                    {% endif %}
                                    
                                    <!-- EV Adjustment -->
                                    {% if streak.streak_analytics.ev_adjustment %}
                                    <div class="ev-adjustment {% if streak.streak_analytics.ev_adjustment.adjustment_pct > 0 %}ev-positive{% elif streak.streak_analytics.ev_adjustment.adjustment_pct < 0 %}ev-negative{% endif %}">
                                        <div class="ev-header">
                                            Streak EV: {% if streak.streak_analytics.ev_adjustment.adjustment_pct > 0 %}+{% endif %}{{ streak.streak_analytics.ev_adjustment.adjustment_pct }}%
                                        </div>
                                        {% if streak.streak_analytics.ev_adjustment.reasoning %}
                                        <div class="ev-reasons">
                                            {% for reason in streak.streak_analytics.ev_adjustment.reasoning[:2] %}
                                            <div class="ev-reason">{{ reason }}</div>
                                            {% endfor %}
                                        </div>
                                        {% endif %}
                                    </div>
                                    {% endif %}
                                </div>
                                {% endif %}
                                
                                {% if streak.factors %}
                                <div class="performance-factors">
                                    <div class="factors-header" onclick="toggleFactors(this)">
                                        <span>üìä Performance Factors</span>
                                        <span class="toggle-icon">‚ñº</span>
                                    </div>
                                    <div class="factors-content" style="display: none;">
                                        {% if streak.factors.injury_risk %}
                                        <div class="factor-badge factor-warning">
                                            ‚ö†Ô∏è Injury Risk ({{ streak.factors.dnp_count }} DNP game{{ 's' if streak.factors.dnp_count != 1 else '' }})
                                        </div>
                                        {% endif %}
                                        {% if streak.factors.rotation_change %}
                                        <div class="factor-badge factor-info">
                                            üîÑ Rotation Change ({{ streak.factors.recent_minutes_avg }} min recent vs {{ streak.factors.older_minutes_avg }} min earlier)
                                        </div>
                                        {% endif %}
                                        <div class="factor-row">
                                            <span class="factor-label">Minutes Trend:</span>
                                            <span class="factor-value trend-{{ streak.factors.minutes_trend }}">
                                                {{ streak.factors.recent_minutes_avg }} min ({{ streak.factors.minutes_trend }})
                                            </span>
                                        </div>
                                        <div class="factor-row">
                                            <span class="factor-label">Performance Trend:</span>
                                            <span class="factor-value trend-{{ streak.factors.performance_trend }}">
                                                {{ streak.factors.performance_trend|title }}
                                            </span>
                                        </div>
                                        {% if streak.factors.shooting_efficiency %}
                                        <div class="factor-row">
                                            <span class="factor-label">FG% (L5):</span>
                                            <span class="factor-value">{{ streak.factors.shooting_efficiency }}%</span>
                                        </div>
                                        {% endif %}
                                    </div>
                                </div>
                                {% endif %}
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            {% endif %}
        </div>

        <div class="projections-section">
            <div class="projections-header">
                <h3>Current Projections (<span id="projectionCount">{{ projections|length }}</span> players)</h3>
                <input type="text" id="playerSearch" placeholder="üîç Search players..." class="player-search" onkeyup="filterPlayers()">
            </div>
            <div class="table-container">
                <table class="projections-table" id="projectionsTable">
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Line</th>
                            <th>Pick</th>
                            <th>Prob</th>
                        </tr>
                    </thead>
                    <tbody id="projectionsTableBody">
                        {% for edge in edges %}
                        <tr>
                            <td>{{ edge.player }}</td>
                            <td>{{ edge.line }}</td>
                            <td class="pick-cell pick-{{ edge.recommendation|lower if edge.recommendation else 'over' }}">{{ edge.recommendation|default('OVER') }}</td>
                            <td>{{ edge.probability|default(70)|round(0)|int }}%</td>
                        </tr>
                        {% endfor %}
                        {% if not edges %}
                        {% for player, line in projections.items() %}
                        <tr>
                            <td>{{ player }}</td>
                            <td>{{ line }}</td>
                            <td class="pick-cell">-</td>
                            <td>-</td>
                        </tr>
                        {% endfor %}
                        {% endif %}
                    </tbody>
                </table>
            </div>
        </div>

        <div class="glitched-props-section">
            <div class="glitched-props-header">
                <h3>üî¥ Glitched Props (Auto-Scanned 24/7)</h3>
                <div class="glitched-props-actions">
                    <button onclick="triggerGlitchedScan()" class="btn-scan-glitch">üîç Run Scan Now</button>
                    <button onclick="showAddGlitchedPropForm()" class="btn-add-glitch">+ Add Manual</button>
                </div>
            </div>
            <div id="glitchedScanStatus" class="scan-status-bar">
                <span id="scanStatusText">Loading scan status...</span>
            </div>
            <div class="table-container">
                <table class="glitched-props-table" id="glitchedPropsTable">
                    <thead>
                        <tr>
                            <th>Prop</th>
                            <th>Source</th>
                            <th>Reasoning</th>
                            <th>Rating</th>
                            <th>Platform</th>
                            <th>Updated</th>
                            <th>Status</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="glitchedPropsTableBody">
                        {% for prop in glitched_props %}
                        <tr data-id="{{ prop.id }}" class="{% if prop.validation and prop.validation.staleness_level == 'stale' %}row-stale{% elif prop.validation and prop.validation.staleness_level == 'warning' %}row-warning{% endif %}">
                            <td>{{ prop.prop }}</td>
                            <td>
                                <span class="source-badge source-{{ prop.source|default('manual') }}">
                                    {{ prop.source_detail|default('Manual') }}
                                </span>
                            </td>
                            <td>{{ prop.reasoning }}</td>
                            <td>
                                <span class="rating-badge rating-{{ prop.rating }}">
                                    {{ prop.rating }}/10
                                </span>
                            </td>
                            <td>{{ prop.platform }}</td>
                            <td class="timestamp-cell" data-timestamp="{{ prop.updated_at }}">{{ prop.updated_at }}</td>
                            <td>
                                {% if prop.validation %}
                                    {% if not prop.validation.is_valid %}
                                        <span class="status-badge status-invalid" title="{{ prop.validation.warnings|join(', ') }}">‚ö†Ô∏è Invalid</span>
                                    {% elif prop.validation.staleness_level == 'stale' %}
                                        <span class="status-badge status-stale" title="Data is over 24 hours old">üî¥ Stale</span>
                                    {% elif prop.validation.staleness_level == 'warning' %}
                                        <span class="status-badge status-warning" title="Data is over 6 hours old">üü° Aging</span>
                                    {% else %}
                                        <span class="status-badge status-fresh">üü¢ Fresh</span>
                                    {% endif %}
                                {% else %}
                                    <span class="status-badge status-unknown">‚ùì Unknown</span>
                                {% endif %}
                            </td>
                            <td>
                                <button onclick="editGlitchedProp({{ prop.id }})" class="btn-edit">‚úèÔ∏è</button>
                                <button onclick="deleteGlitchedProp({{ prop.id }})" class="btn-delete">üóëÔ∏è</button>
                            </td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Add/Edit Glitched Prop Modal -->
        <div id="glitchedPropModal" class="modal" style="display: none;">
            <div class="modal-content">
                <span class="close" onclick="closeGlitchedPropModal()">&times;</span>
                <h3 id="modalTitle">Add Glitched Prop</h3>
                <form id="glitchedPropForm" onsubmit="saveGlitchedProp(event)">
                    <input type="hidden" id="glitchedPropId" value="">
                    <div class="form-group">
                        <label for="glitchedPropInput">Prop:</label>
                        <input type="text" id="glitchedPropInput" placeholder="e.g., LeBron James O 24.5 PTS" required>
                    </div>
                    <div class="form-group">
                        <label for="glitchedReasoningInput">Reasoning:</label>
                        <textarea id="glitchedReasoningInput" placeholder="Why is this glitched? (e.g., Line is 3 points off market average)" required></textarea>
                    </div>
                    <div class="form-group">
                        <label for="glitchedRatingInput">Rating (1-10):</label>
                        <input type="number" id="glitchedRatingInput" min="1" max="10" value="5" required>
                        <small>10 = most glitched/valuable</small>
                    </div>
                    <div class="form-group">
                        <label for="glitchedPlatformInput">Platform:</label>
                        <input type="text" id="glitchedPlatformInput" placeholder="e.g., PrizePicks, Underdog, DraftKings" required>
                    </div>
                    <div class="form-actions">
                        <button type="submit" class="btn-save">Save</button>
                        <button type="button" onclick="closeGlitchedPropModal()" class="btn-cancel">Cancel</button>
                    </div>
                </form>
            </div>
        </div>

        <footer>
            <p>THE ORACLE | NBA API | Real-time edge detection</p>
        </footer>
    </div>

    <script>
        let autoRefreshInterval = null;
        const REFRESH_INTERVAL = 60000; // 60 seconds

        function updatePage(data) {
            // Update timestamp
            document.getElementById('lastUpdate').textContent = `Last updated: ${data.timestamp}`;
            
            // Clear error
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = '';
            
            if (data.error) {
                errorContainer.innerHTML = `<div class="error-message"><strong>Error:</strong> ${data.error}</div>`;
                return;
            }

            // Update player count
            const totalPlayersEl = document.getElementById('totalPlayers');
            const filteredCountEl = document.getElementById('filteredCount');
            const playerCount = data.total_players_loaded || 0;
            if (totalPlayersEl) {
                totalPlayersEl.textContent = playerCount;
                // Update color based on count (green if >0, red if 0)
                totalPlayersEl.style.color = playerCount > 0 ? '#27ae60' : '#e74c3c';
            }
            if (filteredCountEl) filteredCountEl.textContent = data.edges?.length || 0;
            
            // Update edges with pagination
            const edges = data.edges || [];
            allEdges = edges; // Store for pagination
            const edgesContainer = document.getElementById('edgesContainer');
            const showing70Plus = data.showing_70_plus_only !== false;
            
            if (edges.length > 0) {
                // Reset to page 1 if we have new data (different length)
                if (allEdges.length !== edges.length) {
                    currentPage = 1;
                }
                
                const totalPages = Math.ceil(edges.length / itemsPerPage);
                currentPage = Math.min(currentPage, totalPages || 1);
                
                const startIdx = (currentPage - 1) * itemsPerPage;
                const endIdx = startIdx + itemsPerPage;
                const pageEdges = edges.slice(startIdx, endIdx);
                
                edgesContainer.innerHTML = `
                    <div class="edges-section">
                        <div class="section-header">
                            <h2>${showing70Plus ? '70%+ PROBABILITY PROPS' : 'ALL EDGES'} (<span id="edgeCount">${edges.length}</span>)</h2>
                            ${totalPages > 1 ? `
                            <div class="pagination-controls">
                                <button onclick="previousPage()" id="prevBtn" class="page-btn" ${currentPage === 1 ? 'disabled' : ''}>‚Üê Previous</button>
                                <span id="pageInfo">Page ${currentPage} of ${totalPages} (${startIdx + 1}-${Math.min(endIdx, edges.length)} of ${edges.length})</span>
                                <button onclick="nextPage()" id="nextBtn" class="page-btn" ${currentPage === totalPages ? 'disabled' : ''}>Next ‚Üí</button>
                            </div>
                            ` : ''}
                        </div>
                        ${showing70Plus ? '<p class="section-subtitle">Only showing props with 70%+ hit probability from all active NBA players</p>' : '<p class="section-subtitle">Showing all edges (including below 70%)</p>'}
                        <div class="edges-grid" id="edgesGrid">
                            ${pageEdges.map(edge => {
                                const streakBadge = edge.streak && edge.streak.active 
                                    ? renderStreakBadge(edge.streak)
                                    : '';
                                
                                if (edge.oracle) {
                                    const confidenceClass = Math.floor(edge.oracle.confidence);
                                    const advancedMetrics = edge.advanced_metrics 
                                        ? `<div class="advanced-metrics"><div class="metrics-row"><span>FG%:</span> <span>${edge.advanced_metrics.fg_pct}%</span> <span>Pts/36:</span> <span>${edge.advanced_metrics.points_per_36}</span> <span>CV:</span> <span>${edge.advanced_metrics.consistency}%</span></div></div>`
                                        : '';
                                    
                                    const playerName = edge.player || edge.player_name || 'Unknown Player';
                                    const recommendation = edge.recommendation || 'OVER';
                                    return `
                                    <div class="oracle-card ${recommendation.toLowerCase()}">
                                        <div class="oracle-header-row">
                                            <div class="oracle-player">${playerName}</div>
                                            ${edge.ev ? `
                                            <div class="ev-badge ${edge.ev.is_positive_ev ? 'positive-ev' : 'negative-ev'}">
                                                EV: $${edge.ev.ev.toFixed(2)}
                                            </div>
                                            ` : ''}
                                            ${edge.matchup_grade ? `
                                            <div class="grade-badge grade-${edge.matchup_grade.grade.toLowerCase().replace('+', 'plus').replace('-', 'minus')}">
                                                ${edge.matchup_grade.grade}
                                            </div>
                                            ` : ''}
                                        </div>
                                        <div class="oracle-content">
                                            <div class="oracle-line"><strong>The Line:</strong> ${edge.oracle.verdict}</div>
                                            <div class="oracle-sharp"><strong>The Sharp Angle:</strong> ${edge.oracle.sharp_angle}</div>
                                            <div class="oracle-key"><strong>Key Data Point:</strong> ${edge.oracle.key_data}</div>
                                            <div class="oracle-verdict"><strong>The Verdict:</strong> ${edge.oracle.verdict}</div>
                                            <div class="oracle-confidence"><strong>Confidence:</strong> <span class="confidence-badge confidence-${confidenceClass}">${edge.oracle.confidence} Units</span></div>
                                            <div class="oracle-risk"><strong>Risk Factor:</strong> ${edge.oracle.risk_factor}</div>
                                        ${advancedMetrics}
                                    </div>
                                    ${edge.beneficiary ? `
                                    <div class="phase2-analysis">
                                        <div class="phase2-header" onclick="togglePhase2(this)">
                                            <span>‚ö° PHASE 2: STATISTICAL BENEFICIARY</span>
                                            <span class="toggle-icon">‚ñº</span>
                                        </div>
                                        <div class="phase2-content" style="display: none;">
                                            <div class="phase2-item"><strong>1. The Player:</strong> ${edge.beneficiary.player} (${edge.beneficiary.position})</div>
                                            <div class="phase2-item"><strong>2. The Mismatch:</strong> ${edge.beneficiary.mismatch}</div>
                                            <div class="phase2-item"><strong>3. The Consensus Expectation:</strong> ${edge.beneficiary.consensus_expectation} ${edge.stat_type}</div>
                                            <div class="phase2-item"><strong>4. The Projection:</strong> ${edge.beneficiary.projection_direction} (${edge.beneficiary.projection} ${edge.stat_type})</div>
                                            <div class="phase2-item"><strong>5. The Confidence Logic:</strong> ${edge.beneficiary.confidence_logic}</div>
                                            ${edge.beneficiary.matchup_data ? `
                                            <div class="phase2-metrics">
                                                <div class="metric-item"><span>Avg vs Opponent:</span> <span>${edge.beneficiary.matchup_data.avg_vs_opponent}</span></div>
                                                <div class="metric-item"><span>Overall Avg:</span> <span>${edge.beneficiary.matchup_data.overall_avg}</span></div>
                                                ${edge.beneficiary.matchup_data.advantage ? `<div class="metric-item"><span>Advantage:</span> <span class="advantage-positive">+${edge.beneficiary.matchup_data.advantage}</span></div>` : ''}
                                            </div>
                                            ` : ''}
                                        </div>
                                    </div>
                                    ` : ''}
                                    ${streakBadge}
                                    </div>
                                    `;
                                } else {
                                    const playerName = edge.player || edge.player_name || 'Unknown Player';
                                    const recommendation = edge.recommendation || 'OVER';
                                    return `
                                    <div class="edge-card ${recommendation.toLowerCase()}">
                                        <div class="player-name">${playerName}</div>
                                        <div class="edge-details">
                                            <div class="stat-row"><span class="label">Line:</span><span class="value">${edge.line || 'N/A'}</span></div>
                                            <div class="stat-row"><span class="label">L5 Avg:</span><span class="value">${edge.average || 'N/A'}</span></div>
                                            <div class="recommendation"><strong>${recommendation}</strong></div>
                                        </div>
                                        ${streakBadge}
                                    </div>
                                    `;
                                }
                            }).join('')}
                        </div>
                    </div>
                `;
            } else {
                const playerCount = Object.keys(data.projections).length;
                edgesContainer.innerHTML = `
                    <div class="no-edges">
                        <p>No edges found with current threshold.</p>
                        <p class="info">Checked <span id="playerCount">${playerCount}</span> players. Adjust threshold or check projections.</p>
                    </div>
                `;
            }

            // Update streaks (sort by streak count, longest first)
            const streaksContainer = document.getElementById('streaksContainer');
            let streaks = data.streaks || [];
            streaks.sort((a, b) => (b.streak_count || 0) - (a.streak_count || 0));
            
            if (streaks.length > 0) {
                streaksContainer.innerHTML = `
                    <div class="streaks-section">
                        <h2>üî• Active Streaks (<span id="streakCount">${streaks.length}</span>)</h2>
                        <p class="section-subtitle">Players consistently hitting OVER/UNDER for 2+ games</p>
                        <div class="streaks-grid" id="streaksGrid">
                            ${streaks.map(streak => `
                                <div class="streak-card streak-${streak.streak_type.toLowerCase()}">
                                    <div class="player-name">${streak.player}</div>
                                    <div class="streak-details">
                                        <div class="stat-row">
                                            <span class="label">Line:</span>
                                            <span class="value">${streak.line}</span>
                                        </div>
                                        ${streak.average ? `
                                        <div class="stat-row">
                                            <span class="label">L5 Average:</span>
                                            <span class="value">${streak.average}</span>
                                        </div>
                                        ` : ''}
                                        <div class="streak-info">
                                            <div class="streak-badge-large streak-${streak.streak_type.toLowerCase()}">
                                                üî• ${streak.streak_count}-game ${streak.streak_type} streak
                                            </div>
                                        </div>
                                        ${streak.factors ? `
                                        <div class="performance-factors">
                                            <div class="factors-header" onclick="toggleFactors(this)">
                                                <span>üìä Performance Factors</span>
                                                <span class="toggle-icon">‚ñº</span>
                                            </div>
                                            <div class="factors-content" style="display: none;">
                                                ${edge.factors.injury_risk ? `
                                                <div class="factor-badge factor-warning">
                                                    ‚ö†Ô∏è Injury Risk (${edge.factors.dnp_count} DNP game${edge.factors.dnp_count !== 1 ? 's' : ''})
                                                </div>
                                                ` : ''}
                                                ${edge.factors.rotation_change ? `
                                                <div class="factor-badge factor-info">
                                                    üîÑ Rotation Change (${edge.factors.recent_minutes_avg} min recent vs ${edge.factors.older_minutes_avg} min earlier)
                                                </div>
                                                ` : ''}
                                                <div class="factor-row">
                                                    <span class="factor-label">Minutes Trend:</span>
                                                    <span class="factor-value trend-${edge.factors.minutes_trend}">
                                                        ${edge.factors.recent_minutes_avg} min (${edge.factors.minutes_trend})
                                                    </span>
                                                </div>
                                                <div class="factor-row">
                                                    <span class="factor-label">Performance Trend:</span>
                                                    <span class="factor-value trend-${edge.factors.performance_trend}">
                                                        ${edge.factors.performance_trend.charAt(0).toUpperCase() + edge.factors.performance_trend.slice(1)}
                                                    </span>
                                                </div>
                                                ${edge.factors.shooting_efficiency ? `
                                                <div class="factor-row">
                                                    <span class="factor-label">FG% (L5):</span>
                                                    <span class="factor-value">${edge.factors.shooting_efficiency}%</span>
                                                </div>
                                                ` : ''}
                                            </div>
                                        </div>
                                        ` : ''}
                                    </div>
                                </div>
                            `;
                            }).join('')}
                        </div>
                    </div>
                `;
            } else {
                const playerCount = Object.keys(data.projections).length;
                edgesContainer.innerHTML = `
                    <div class="no-edges">
                        <p>No edges found with current threshold.</p>
                        <p class="info">Checked <span id="playerCount">${playerCount}</span> players. Adjust threshold or check projections.</p>
                    </div>
                `;
            }

            // Update streaks (sort by streak count, longest first)
            const streaksContainer = document.getElementById('streaksContainer');
            let streaks = data.streaks || [];
            streaks.sort((a, b) => (b.streak_count || 0) - (a.streak_count || 0));
            
            if (streaks.length > 0) {
                streaksContainer.innerHTML = `
                    <div class="streaks-section">
                        <h2>üî• Active Streaks (<span id="streakCount">${streaks.length}</span>)</h2>
                        <p class="section-subtitle">Players consistently hitting OVER/UNDER for 2+ games</p>
                        <div class="streaks-grid" id="streaksGrid">
                            ${streaks.map(streak => `
                                <div class="streak-card streak-${streak.streak_type.toLowerCase()}">
                                    <div class="player-name">${streak.player}</div>
                                    <div class="streak-details">
                                        <div class="stat-row">
                                            <span class="label">Line:</span>
                                            <span class="value">${streak.line}</span>
                                        </div>
                                        ${streak.average ? `
                                        <div class="stat-row">
                                            <span class="label">L5 Average:</span>
                                            <span class="value">${streak.average}</span>
                                        </div>
                                        ` : ''}
                                        <div class="streak-info">
                                            <div class="streak-badge-large streak-${streak.streak_type.toLowerCase()}">
                                                üî• ${streak.streak_count}-game ${streak.streak_type} streak
                                            </div>
                                        </div>
                                        ${streak.factors ? `
                                        <div class="performance-factors">
                                            <div class="factors-header" onclick="toggleFactors(this)">
                                                <span>üìä Performance Factors</span>
                                                <span class="toggle-icon">‚ñº</span>
                                            </div>
                                            <div class="factors-content" style="display: none;">
                                                ${streak.factors.injury_risk ? `
                                                <div class="factor-badge factor-warning">
                                                    ‚ö†Ô∏è Injury Risk (${streak.factors.dnp_count} DNP game${streak.factors.dnp_count !== 1 ? 's' : ''})
                                                </div>
                                                ` : ''}
                                                ${streak.factors.rotation_change ? `
                                                <div class="factor-badge factor-info">
                                                    üîÑ Rotation Change (${streak.factors.recent_minutes_avg} min recent vs ${streak.factors.older_minutes_avg} min earlier)
                                                </div>
                                                ` : ''}
                                                <div class="factor-row">
                                                    <span class="factor-label">Minutes Trend:</span>
                                                    <span class="factor-value trend-${streak.factors.minutes_trend}">
                                                        ${streak.factors.recent_minutes_avg} min (${streak.factors.minutes_trend})
                                                    </span>
                                                </div>
                                                <div class="factor-row">
                                                    <span class="factor-label">Performance Trend:</span>
                                                    <span class="factor-value trend-${streak.factors.performance_trend}">
                                                        ${streak.factors.performance_trend.charAt(0).toUpperCase() + streak.factors.performance_trend.slice(1)}
                                                    </span>
                                                </div>
                                                ${streak.factors.shooting_efficiency ? `
                                                <div class="factor-row">
                                                    <span class="factor-label">FG% (L5):</span>
                                                    <span class="factor-value">${streak.factors.shooting_efficiency}%</span>
                                                </div>
                                                ` : ''}
                                            </div>
                                        </div>
                                        ` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            } else {
                streaksContainer.innerHTML = '';
            }

            // Update parlay recommendations
            checkParlayRecommendations(data);
            
            // Update high probability props
            const highProbContainer = document.getElementById('highProbContainer');
            const highProbProps = data.high_prob_props || [];
            
            if (highProbProps.length > 0) {
                highProbContainer.innerHTML = `
                    <div class="high-prob-section">
                        <h2>üéØ HIGH PROBABILITY PROPS (70%+) - <span id="highProbCount">${highProbProps.length}</span></h2>
                        <p class="section-subtitle">PrizePicks/Underdog Format | Sorted by Probability</p>
                        <div class="high-prob-grid" id="highProbGrid">
                            ${highProbProps.map(prop => {
                                const streakBadge = prop.edge.streak && prop.edge.streak.active 
                                    ? `<div class="streak-indicator">üî• ${prop.edge.streak.streak_count}-game ${prop.edge.streak.streak_type} streak</div>`
                                    : '';
                                const matchupBadge = prop.beneficiary 
                                    ? `<div class="matchup-indicator">‚ö° vs ${prop.beneficiary.opponent}: ${prop.beneficiary.mismatch}</div>`
                                    : '';
                                
                                return `
                                <div class="high-prob-card">
                                    <div class="prob-header">
                                        <div class="prob-badge">${prop.probability}%</div>
                                        <div class="prizepicks-display">${prop.prizepicks.display}</div>
                                    </div>
                                    <div class="prob-details">
                                        <div class="prob-reasoning">
                                            <strong>Reasoning:</strong> ${prop.reasoning}
                                        </div>
                                        <div class="prob-stats">
                                            <div class="stat-item">
                                                <span>L5 Average:</span>
                                                <span>${prop.edge.average}</span>
                                            </div>
                                            <div class="stat-item">
                                                <span>Line:</span>
                                                <span>${prop.edge.line}</span>
                                            </div>
                                            <div class="stat-item">
                                                <span>Edge:</span>
                                                <span class="edge-value">${prop.edge.difference}pts</span>
                                            </div>
                                        </div>
                                        ${streakBadge}
                                        ${matchupBadge}
                                    </div>
                                </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            } else {
                highProbContainer.innerHTML = '';
            }

            // Update projections table with edges (includes over/under picks)
            const projectionsTable = document.getElementById('projectionsTable');
            const tbody = document.getElementById('projectionsTableBody');
            const projectionCount = document.getElementById('projectionCount');
            
            // Use edges data if available (has picks), otherwise fall back to projections
            const edges = data.edges || [];
            if (edges.length > 0) {
                tbody.innerHTML = edges.map(edge => `
                    <tr>
                        <td>${edge.player || 'Unknown'}</td>
                        <td>${edge.line || 0}</td>
                        <td class="pick-cell pick-${(edge.recommendation || 'over').toLowerCase()}">${edge.recommendation || 'OVER'}</td>
                        <td>${Math.round(edge.probability || 70)}%</td>
                    </tr>
                `).join('');
                projectionCount.textContent = edges.length;
            } else if (data.projections) {
                tbody.innerHTML = Object.entries(data.projections).map(([player, line]) => `
                    <tr>
                        <td>${player}</td>
                        <td>${line}</td>
                        <td class="pick-cell">-</td>
                        <td>-</td>
                    </tr>
                `).join('');
                projectionCount.textContent = Object.keys(data.projections).length;
            }

            // Update glitched props
            if (data.glitched_props) {
                updateGlitchedPropsTable(data.glitched_props);
            }
        }

        function filterPlayers() {
            const searchInput = document.getElementById('playerSearch');
            const filter = searchInput.value.toLowerCase();
            const table = document.getElementById('projectionsTable');
            const rows = table.getElementsByTagName('tr');
            
            let visibleCount = 0;
            
            // Start from index 1 to skip header row
            for (let i = 1; i < rows.length; i++) {
                const playerCell = rows[i].getElementsByTagName('td')[0];
                if (playerCell) {
                    const playerName = playerCell.textContent || playerCell.innerText;
                    if (playerName.toLowerCase().indexOf(filter) > -1) {
                        rows[i].style.display = '';
                        visibleCount++;
                    } else {
                        rows[i].style.display = 'none';
                    }
                }
            }
        }

        let refreshTimeout = null;
        let isRefreshing = false;
        let currentMinProbability = 70;  // Probability filter (60/70/80/All)
        
        function buildFilterParams() {
            const params = new URLSearchParams();
            
            // Stat type
            const statTypeSelect = document.getElementById('statTypeSelect');
            if (statTypeSelect) {
                params.append('stat_type', statTypeSelect.value);
            }
            
            // Show all toggle - use currentMinProbability from tabs
            if (currentMinProbability === 0) {
                params.append('show_all', 'true');
            }
            
            // Sort by
            const sortSelect = document.getElementById('sortSelect');
            if (sortSelect) {
                params.append('sort_by', sortSelect.value);
            }
            
            // Filters - use currentMinProbability from tabs (higher priority than slider)
            const minProb = currentMinProbability > 0 ? currentMinProbability : 50;
            params.append('min_probability', minProb);
            
            const minEvFilter = document.getElementById('minEvFilter');
            if (minEvFilter) {
                params.append('min_ev', minEvFilter.value);
            }
            
            const minEdgeFilter = document.getElementById('minEdgeFilter');
            if (minEdgeFilter) {
                params.append('min_market_edge', minEdgeFilter.value);
            }
            
            const minGradeFilter = document.getElementById('minGradeFilter');
            if (minGradeFilter && minGradeFilter.value) {
                params.append('min_grade', minGradeFilter.value);
            }
            
            const positiveEvOnly = document.getElementById('positiveEvOnly');
            if (positiveEvOnly && positiveEvOnly.checked) {
                params.append('positive_ev_only', 'true');
            }
            
            const excludeInjuries = document.getElementById('excludeInjuries');
            if (excludeInjuries && excludeInjuries.checked) {
                params.append('exclude_injuries', 'true');
            }
            
            const excludeRotation = document.getElementById('excludeRotation');
            if (excludeRotation && excludeRotation.checked) {
                params.append('exclude_rotation', 'true');
            }
            
            return params.toString();
        }

        async function refreshData() {
            // Debounce: prevent multiple simultaneous refreshes
            if (isRefreshing) {
                console.log('Refresh already in progress, skipping...');
                return Promise.resolve();
            }
            
            isRefreshing = true;
            const refreshBtn = document.getElementById('refreshBtn');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const showAllToggle = document.getElementById('showAllToggle');
            const showAll = showAllToggle ? showAllToggle.checked : false;
            
            if (refreshBtn) refreshBtn.disabled = true;
            if (loadingIndicator) loadingIndicator.style.display = 'inline';
            
            try {
                const filterParams = buildFilterParams();
                const url = '/api/edges' + (filterParams ? '?' + filterParams : '');
                const response = await fetch(url);
                const data = await response.json();
                updatePage(data);
                return Promise.resolve(data); // Return data for chaining
            } catch (error) {
                const errorContainer = document.getElementById('errorContainer');
                if (errorContainer) {
                    errorContainer.innerHTML = 
                        `<div class="error-message"><strong>Error:</strong> Failed to fetch data: ${error.message}</div>`;
                }
                return Promise.reject(error);
            } finally {
                if (refreshBtn) refreshBtn.disabled = false;
                if (loadingIndicator) loadingIndicator.style.display = 'none';
                isRefreshing = false;  // Reset flag
            }
        }

        function toggleShowAll() {
            refreshData();
        }

        function changeStatType() {
            try {
                const statTypeSelect = document.getElementById('statTypeSelect');
                const statDesc = document.getElementById('statDescription');
                
                if (!statTypeSelect) {
                    console.error('Stat type select not found');
                    return;
                }
                
                const statType = statTypeSelect.value;
                
                // Update description
                const statCategories = {{ stat_categories|tojson|default('{}') }};
                if (statCategories && statCategories[statType] && statDesc) {
                    statDesc.textContent = statCategories[statType].description || '';
                }
                
                // Refresh data with new stat type
                if (typeof refreshData === 'function') {
                    refreshData();
                }
            } catch (e) {
                console.error('Error in changeStatType:', e);
            }
        }

        function setMinProbability(minProb) {
            try {
                currentMinProbability = minProb;
                
                // Update active tab styling
                document.querySelectorAll('.prob-tab').forEach(tab => tab.classList.remove('active'));
                const probEl = document.getElementById(minProb === 60 ? 'prob60' : minProb === 70 ? 'prob70' : minProb === 80 ? 'prob80' : 'probAll');
                if (probEl) probEl.classList.add('active');
                
                // Update the min probability filter slider if it exists
                const minProbFilter = document.getElementById('minProbFilter');
                if (minProbFilter) {
                    minProbFilter.value = minProb || 50;
                    const probValue = document.getElementById('probValue');
                    if (probValue) probValue.textContent = minProb || 50;
                }
                
                // Update the show all toggle based on probability
                const showAllToggle = document.getElementById('showAllToggle');
                if (showAllToggle) {
                    showAllToggle.checked = (minProb === 0);
                }
                
                // Update subtitle text
                const subtitle = document.querySelector('.subtitle');
                if (subtitle) {
                    if (minProb === 0) {
                        subtitle.textContent = 'Sharp angles. No fluff. Pure edge. | Showing ALL props';
                    } else {
                        subtitle.textContent = `Sharp angles. No fluff. Pure edge. | Showing ${minProb}%+ probability props only`;
                    }
                }
                
                // Refresh data with new filter
                if (typeof refreshData === 'function') {
                    refreshData();
                }
            } catch (e) {
                console.error('Error in setMinProbability:', e);
            }
        }

        function toggleAutoRefresh() {
            const checkbox = document.getElementById('autoRefresh');
            
            if (checkbox.checked) {
                // Start auto-refresh
                autoRefreshInterval = setInterval(refreshData, REFRESH_INTERVAL);
                console.log('Auto-refresh enabled');
            } else {
                // Stop auto-refresh
                if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                    autoRefreshInterval = null;
                }
                console.log('Auto-refresh disabled');
            }
        }

        // Load ALL active players (not just relevant ones) - unified function
        async function loadAllPlayers() {
            const btn = document.getElementById('loadAllBtn');
            if (!btn) return;
            
            if (!confirm('This will load ALL active NBA players (500+ players).\n\n' +
                        'This takes 10-15 minutes due to API rate limits.\n\n' +
                        'The page will auto-refresh every 30 seconds to show progress.\n\n' +
                        'Continue?')) {
                return;
            }
            
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = '‚è≥ Loading All Players...';
            
            try {
                const statType = document.getElementById('statTypeSelect')?.value || 'PTS';
                const response = await fetch('/api/load-all-players', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        stat_type: statType,
                        season: '2023-24'
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    alert('‚úÖ Player loading started in background!\n\n' + 
                          'This will take 10-15 minutes.\n\n' +
                          'The page will auto-refresh every 30 seconds to show progress.\n' +
                          'You can continue using the app while it loads.');
                    
                    // Refresh data after 30 seconds to check progress
                    setTimeout(() => {
                        refreshData();
                    }, 30000);
                } else {
                    alert('‚ùå Error: ' + (data.error || 'Failed to start loading'));
                    btn.disabled = false;
                    btn.textContent = originalText;
                }
            } catch (error) {
                alert('‚ùå Error: ' + error.message);
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }
        
        // Check projections status on page load
        async function checkProjectionsStatus() {
            try {
                const response = await fetch('/api/projections');
                const data = await response.json();
                
                if (data.is_default_only) {
                    const warningDiv = document.createElement('div');
                    warningDiv.className = 'warning-banner';
                    warningDiv.style.cssText = 'background: rgba(243, 156, 18, 0.2); border: 2px solid #f39c12; padding: 15px; margin: 20px 0; border-radius: 8px; text-align: center;';
                    warningDiv.innerHTML = `
                        <strong style="color: #f39c12; font-size: 1.1em;">‚ö†Ô∏è Only Default Players Loaded</strong><br>
                        <p>Currently showing only ${data.count} default players: ${data.default_players.join(', ')}</p>
                        <p><strong>Click "üì• Load All Active Players" button to load 100+ active NBA players.</strong></p>
                        <p style="font-size: 0.9em; color: #888;">This takes 10-15 minutes but runs in background.</p>
                    `;
                    const container = document.querySelector('.container');
                    if (container) {
                        container.insertBefore(warningDiv, container.firstChild);
                    }
                }
            } catch (error) {
                console.error('Error checking projections status:', error);
            }
        }
        
        async function checkPlayerCount() {
            const loadBtn = document.getElementById('loadPlayersBtn');
            const progressDiv = document.getElementById('loadProgress');
            const progressText = document.getElementById('progressText');
            const progressFill = document.getElementById('progressFill');
            
            if (!confirm('This will load ALL active NBA players and may take 10-15 minutes due to API rate limits. Continue?')) {
                return;
            }
            
            loadBtn.disabled = true;
            progressDiv.style.display = 'block';
            progressText.textContent = 'Starting to load all active players...';
            progressFill.style.width = '0%';
            
            try {
                const response = await fetch('/api/load-all-players', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        season: '2023-24',
                        stat_type: 'PTS'
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    progressFill.style.width = '100%';
                    progressText.textContent = `Successfully loaded ${data.count} players!`;
                    
                    // Refresh the page data after a short delay
                    setTimeout(() => {
                        refreshData();
                        progressDiv.style.display = 'none';
                        alert(`Successfully loaded ${data.count} active NBA players!`);
                    }, 2000);
                } else {
                    progressText.textContent = `Error: ${data.error}`;
                    alert(`Error loading players: ${data.error}`);
                }
            } catch (error) {
                progressText.textContent = `Error: ${error.message}`;
                alert(`Failed to load players: ${error.message}`);
            } finally {
                loadBtn.disabled = false;
            }
        }

        function toggleFactors(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.toggle-icon');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '‚ñ≤';
            } else {
                content.style.display = 'none';
                icon.textContent = '‚ñº';
            }
        }

        function togglePhase2(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.toggle-icon');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '‚ñ≤';
            } else {
                content.style.display = 'none';
                icon.textContent = '‚ñº';
            }
        }

        // Line Management Functions
        function showLineManagement() {
            try {
                const panel = document.getElementById('lineManagementPanel');
                if (!panel) {
                    console.error('lineManagementPanel element not found');
                    alert('Line Management panel not found. Please refresh the page.');
                    return;
                }
                panel.style.display = 'block';
                if (typeof loadLineChanges === 'function') loadLineChanges();
                if (typeof loadChaseList === 'function') loadChaseList();
                if (typeof loadAltLines === 'function') loadAltLines();
                if (typeof loadDailyUpdateStatus === 'function') loadDailyUpdateStatus();
            } catch (error) {
                console.error('Error showing line management:', error);
                alert('Error opening Line Management: ' + error.message);
            }
        }

        function hideLineManagement() {
            document.getElementById('lineManagementPanel').style.display = 'none';
        }

        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(`tab-${tabName}`).classList.add('active');
            event.target.classList.add('active');
        }

        async function loadLineChanges() {
            try {
                const response = await fetch('/api/line-changes');
                const data = await response.json();
                const container = document.getElementById('lineChangesContainer');
                
                if (data.changes && Object.keys(data.changes).length > 0) {
                    container.innerHTML = Object.entries(data.changes).map(([player, change]) => `
                        <div class="line-change-card">
                            <div class="change-player">${player}</div>
                            <div class="change-details">
                                <span class="old-line">${change.previous}</span>
                                <span class="arrow">‚Üí</span>
                                <span class="new-line">${change.current}</span>
                                <span class="movement ${change.direction}">${change.movement > 0 ? '+' : ''}${change.movement}</span>
                            </div>
                            <div class="change-direction">Line moved ${change.direction}</div>
                        </div>
                    `).join('');
                } else {
                    container.innerHTML = '<p class="no-data">No line changes detected in last 24h</p>';
                }
            } catch (error) {
                console.error('Error loading line changes:', error);
            }
        }

        async function loadChaseList() {
            try {
                const response = await fetch('/api/chase-list');
                const data = await response.json();
                const container = document.getElementById('chaseListContainer');
                
                if (data.chase_list && data.chase_list.length > 0) {
                    container.innerHTML = data.chase_list.map(item => `
                        <div class="chase-item">
                            <div class="chase-player">${item.player}</div>
                            <div class="chase-line">Line: ${item.line} ${item.stat_type}</div>
                            <div class="chase-reason">${item.reason || 'No reason provided'}</div>
                            <button onclick="removeFromChase('${item.player}', '${item.stat_type}')" class="remove-btn">Remove</button>
                        </div>
                    `).join('');
                } else {
                    container.innerHTML = '<p class="no-data">No props in chase list</p>';
                }
            } catch (error) {
                console.error('Error loading chase list:', error);
            }
        }

        async function loadAltLines() {
            try {
                const response = await fetch('/api/alt-lines');
                const data = await response.json();
                const container = document.getElementById('altLinesContainer');
                
                if (data.alt_lines && Object.keys(data.alt_lines).length > 0) {
                    container.innerHTML = Object.entries(data.alt_lines).map(([player, lines]) => `
                        <div class="alt-line-card">
                            <div class="alt-player">${player}</div>
                            ${lines.map(line => `
                                <div class="alt-line-item">
                                    <span>Main: ${line.main_line}</span>
                                    <span>Alt: ${line.alt_line}</span>
                                    <span class="diff">Diff: ${line.difference > 0 ? '+' : ''}${line.difference}</span>
                                    <span class="source">${line.source || 'Unknown'}</span>
                                </div>
                            `).join('')}
                        </div>
                    `).join('');
                } else {
                    container.innerHTML = '<p class="no-data">No alternative lines tracked</p>';
                }
            } catch (error) {
                console.error('Error loading alt lines:', error);
            }
        }

        async function updateLine() {
            const player = document.getElementById('editPlayerSelect').value;
            const oldLine = parseFloat(document.getElementById('oldLineInput').value);
            const newLine = parseFloat(document.getElementById('newLineInput').value);
            
            if (!player || isNaN(oldLine) || isNaN(newLine)) {
                alert('Please fill in all fields');
                return;
            }
            
            try {
                const response = await fetch('/api/update-line', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        player: player,
                        old_line: oldLine,
                        new_line: newLine,
                        stat_type: 'PTS'
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    document.getElementById('editResult').innerHTML = 
                        `<div class="success-msg">‚úÖ ${data.message}</div>`;
                    // Clear inputs
                    document.getElementById('oldLineInput').value = '';
                    document.getElementById('newLineInput').value = '';
                    // Refresh data
                    refreshData();
                } else {
                    document.getElementById('editResult').innerHTML = 
                        `<div class="error-msg">‚ùå ${data.error}</div>`;
                }
            } catch (error) {
                document.getElementById('editResult').innerHTML = 
                    `<div class="error-msg">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function removeFromChase(player, statType) {
            try {
                const response = await fetch('/api/chase-list', {
                    method: 'DELETE',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({player: player, stat_type: statType})
                });
                
                if (response.ok) {
                    loadChaseList();
                }
            } catch (error) {
                console.error('Error removing from chase list:', error);
            }
        }

        async function loadDailyUpdateStatus() {
            try {
                const response = await fetch('/api/daily-update-status');
                const data = await response.json();
                const statusEl = document.getElementById('dailyUpdateStatus');
                
                if (data.daily_update_scheduled && data.next_run) {
                    const nextRun = new Date(data.next_run);
                    const now = new Date();
                    const hoursUntil = Math.floor((nextRun - now) / (1000 * 60 * 60));
                    const minsUntil = Math.floor(((nextRun - now) % (1000 * 60 * 60)) / (1000 * 60));
                    
                    statusEl.textContent = `‚è∞ Next update: ${hoursUntil}h ${minsUntil}m`;
                    statusEl.style.color = '#ffd700';
                } else {
                    statusEl.textContent = '‚è∞ Daily update: Not scheduled';
                    statusEl.style.color = '#888';
                }
            } catch (error) {
                console.error('Error loading update status:', error);
            }
        }

        // Tactical Filters Functions
        function showTacticalFilters() {
            try {
                const panel = document.getElementById('tacticalFiltersPanel');
                if (!panel) {
                    console.error('tacticalFiltersPanel element not found');
                    alert('Tactical Filters panel not found. Please refresh the page.');
                    return;
                }
                panel.style.display = 'block';
            } catch (error) {
                console.error('Error showing tactical filters:', error);
                alert('Error opening Tactical Filters: ' + error.message);
            }
        }

        function hideTacticalFilters() {
            const panel = document.getElementById('tacticalFiltersPanel');
            if (panel) panel.style.display = 'none';
            // Apply filters when closing
            refreshData();
        }

        // ============================================
        // PARLAY CALCULATOR FUNCTIONS
        // ============================================
        
        function showParlayCalculator() {
            try {
                const modal = document.getElementById('parlayCalculatorModal');
                if (!modal) {
                    console.error('parlayCalculatorModal not found');
                    alert('Parlay Calculator not available. Please refresh the page.');
                    return;
                }
                modal.style.display = 'block';
                // Load parlay recommendations from API
                loadParlayRecommendations();
            } catch (e) {
                console.error('Error showing parlay calculator:', e);
                alert('Error opening Parlay Calculator: ' + e.message);
            }
        }

        function hideParlayCalculator() {
            const modal = document.getElementById('parlayCalculatorModal');
            if (modal) modal.style.display = 'none';
        }

        function showParlayTab(tabId) {
            try {
                // Hide all tab contents
                document.querySelectorAll('.parlay-tab-content').forEach(c => c.classList.remove('active'));
                document.querySelectorAll('.parlay-tab').forEach(t => t.classList.remove('active'));
                // Show selected tab
                const content = document.getElementById('parlay-' + tabId);
                if (content) content.classList.add('active');
                // Mark clicked tab as active
                if (event && event.target) event.target.classList.add('active');
            } catch (e) {
                console.error('Error switching parlay tab:', e);
            }
        }

        function checkParlayRecommendations(data) {
            try {
                // Populate parlay containers with recommendations from API data
                if (data && data.parlay_recommendations) {
                    renderParlayRecommendations(data.parlay_recommendations);
                }
            } catch (e) {
                console.error('Error checking parlay recommendations:', e);
            }
        }

        function renderParlayRecommendations(recommendations) {
            try {
                // Render 2-man parlays
                const container2 = document.getElementById('parlay2ManContainer');
                if (container2) {
                    container2.innerHTML = recommendations['2_man'] ? renderParlayList(recommendations['2_man'], 2) : '<div class="no-parlays">No 2-man parlays available</div>';
                }
                
                // Render 3-man parlays
                const container3 = document.getElementById('parlay3ManContainer');
                if (container3) {
                    container3.innerHTML = recommendations['3_man'] ? renderParlayList(recommendations['3_man'], 3) : '<div class="no-parlays">No 3-man parlays available</div>';
                }
                
                // Render 4-man parlays
                const container4 = document.getElementById('parlay4ManContainer');
                if (container4) {
                    container4.innerHTML = recommendations['4_man'] ? renderParlayList(recommendations['4_man'], 4) : '<div class="no-parlays">No 4-man parlays available</div>';
                }
                
                // Render 5-man parlays
                const container5 = document.getElementById('parlay5ManContainer');
                if (container5) {
                    container5.innerHTML = recommendations['5_man'] ? renderParlayList(recommendations['5_man'], 5) : '<div class="no-parlays">No 5-man parlays available</div>';
                }
                
                // Render 6-man parlays
                const container6 = document.getElementById('parlay6ManContainer');
                if (container6) {
                    container6.innerHTML = recommendations['6_man'] ? renderParlayList(recommendations['6_man'], 6) : '<div class="no-parlays">No 6-man parlays available</div>';
                }
            } catch (e) {
                console.error('Error rendering parlay recommendations:', e);
            }
        }
        
        // Custom parlay builder
        let customBets = [];
        
        function addBetRow() {
            const betsList = document.getElementById('betsList');
            if (!betsList) return;
            
            const rowId = Date.now();
            const row = document.createElement('div');
            row.className = 'bet-row';
            row.id = `bet-${rowId}`;
            row.innerHTML = `
                <input type="text" placeholder="Player name" class="bet-player" />
                <select class="bet-pick">
                    <option value="OVER">OVER</option>
                    <option value="UNDER">UNDER</option>
                </select>
                <input type="number" placeholder="Line" class="bet-line" step="0.5" />
                <input type="number" placeholder="Prob %" class="bet-prob" value="70" />
                <button onclick="removeBetRow('${rowId}')" class="remove-bet">‚úï</button>
            `;
            betsList.appendChild(row);
        }
        
        function removeBetRow(rowId) {
            const row = document.getElementById(`bet-${rowId}`);
            if (row) row.remove();
        }
        
        function calculateCustomParlay() {
            const betsList = document.getElementById('betsList');
            const resultsDiv = document.getElementById('calculatorResults');
            if (!betsList || !resultsDiv) return;
            
            const rows = betsList.querySelectorAll('.bet-row');
            if (rows.length < 2) {
                resultsDiv.innerHTML = '<div class="calc-error">Need at least 2 legs for a parlay</div>';
                return;
            }
            
            let bets = [];
            let combinedProb = 1;
            let combinedOdds = 1;
            
            rows.forEach(row => {
                const player = row.querySelector('.bet-player')?.value || 'Unknown';
                const pick = row.querySelector('.bet-pick')?.value || 'OVER';
                const line = parseFloat(row.querySelector('.bet-line')?.value) || 0;
                const prob = parseFloat(row.querySelector('.bet-prob')?.value) || 70;
                
                bets.push({ player, pick, line, prob });
                combinedProb *= (prob / 100);
                
                // Assume -110 odds for each leg
                const decimalOdds = 1.909; // -110 in decimal
                combinedOdds *= decimalOdds;
            });
            
            const americanOdds = combinedOdds >= 2 ? Math.round((combinedOdds - 1) * 100) : Math.round(-100 / (combinedOdds - 1));
            const payout = (combinedOdds - 1) * 100;
            const ev = (combinedProb * payout) - 100;
            
            resultsDiv.innerHTML = `
                <div class="calc-result">
                    <div class="result-row">
                        <span class="result-label">Legs:</span>
                        <span class="result-value">${bets.length}</span>
                    </div>
                    <div class="result-row">
                        <span class="result-label">Combined Probability:</span>
                        <span class="result-value">${(combinedProb * 100).toFixed(1)}%</span>
                    </div>
                    <div class="result-row">
                        <span class="result-label">Parlay Odds:</span>
                        <span class="result-value">${americanOdds > 0 ? '+' : ''}${americanOdds}</span>
                    </div>
                    <div class="result-row">
                        <span class="result-label">$100 Wins:</span>
                        <span class="result-value">$${payout.toFixed(2)}</span>
                    </div>
                    <div class="result-row">
                        <span class="result-label">Expected Value:</span>
                        <span class="result-value ${ev >= 0 ? 'positive' : 'negative'}">${ev >= 0 ? '+' : ''}$${ev.toFixed(2)}</span>
                    </div>
                </div>
                <div class="calc-legs">
                    <h4>Your Legs:</h4>
                    ${bets.map(b => `<div class="leg-item">${b.player} ${b.pick} ${b.line} (${b.prob}%)</div>`).join('')}
                </div>
            `;
        }

        function renderParlayList(parlays, legCount) {
            if (!parlays || parlays.length === 0) {
                return `<div class="no-parlays">No ${legCount}-man parlays available. Need more high-probability props.</div>`;
            }
            
            return parlays.map((parlay, idx) => `
                <div class="parlay-card">
                    <div class="parlay-header">
                        <span class="parlay-rank">#${idx + 1}</span>
                        <span class="parlay-odds">${parlay.payout?.american_odds > 0 ? '+' : ''}${parlay.payout?.american_odds || 'N/A'}</span>
                        <span class="parlay-prob">${parlay.total_probability?.toFixed(1) || 0}%</span>
                    </div>
                    <div class="parlay-legs">
                        ${parlay.bets?.map(bet => `
                            <div class="parlay-leg">
                                <span class="leg-player">${bet.player || 'Unknown'}</span>
                                <span class="leg-pick ${(bet.recommendation || '').toLowerCase()}">${bet.recommendation || 'OVER'} ${bet.line || 0}</span>
                                <span class="leg-prob">${bet.probability || 0}%</span>
                            </div>
                        `).join('') || ''}
                    </div>
                    <div class="parlay-footer">
                        <span class="parlay-payout">$100 wins $${parlay.payout?.profit_per_100?.toFixed(2) || '0.00'}</span>
                        <span class="parlay-ev ${(parlay.expected_value || 0) >= 0 ? 'positive' : 'negative'}">EV: ${(parlay.expected_value || 0) >= 0 ? '+' : ''}$${parlay.expected_value?.toFixed(2) || '0.00'}</span>
                    </div>
                </div>
            `).join('');
        }

        async function loadParlayRecommendations() {
            try {
                const response = await fetch('/api/parlay-calculator');
                const data = await response.json();
                
                if (data.success && data.recommendations) {
                    renderParlayRecommendations(data.recommendations);
                } else {
                    console.error('Failed to load parlay recommendations:', data.error);
                }
            } catch (e) {
                console.error('Error loading parlay recommendations:', e);
            }
        }

        function applyFilters() {
            // Refresh data with current filter settings
            refreshData();
        }

        function resetFilters() {
            // Reset all filter inputs to defaults
            const minProbFilter = document.getElementById('minProbFilter');
            if (minProbFilter) {
                minProbFilter.value = 70;
                document.getElementById('probValue').textContent = '70';
            }
            
            const minEvFilter = document.getElementById('minEvFilter');
            if (minEvFilter) {
                minEvFilter.value = 0;
                document.getElementById('evValue').textContent = '0';
            }
            
            const minEdgeFilter = document.getElementById('minEdgeFilter');
            if (minEdgeFilter) {
                minEdgeFilter.value = 0;
                document.getElementById('edgeValue').textContent = '0';
            }
            
            const minGradeFilter = document.getElementById('minGradeFilter');
            if (minGradeFilter) {
                minGradeFilter.value = 'B';
            }
            
            const sortSelect = document.getElementById('sortSelect');
            if (sortSelect) {
                sortSelect.value = 'ev';
            }
            
            const positiveEvOnly = document.getElementById('positiveEvOnly');
            if (positiveEvOnly) {
                positiveEvOnly.checked = false;
            }
            
            const excludeInjuries = document.getElementById('excludeInjuries');
            if (excludeInjuries) {
                excludeInjuries.checked = false;
            }
            
            const excludeRotation = document.getElementById('excludeRotation');
            if (excludeRotation) {
                excludeRotation.checked = false;
            }
            
            // Apply reset filters
            refreshData();
        }

        // Add to Chase List function
        async function addToChaseList(player, statType, line) {
            try {
                const response = await fetch('/api/chase-list', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        player: player,
                        stat_type: statType || 'PTS',
                        line: line
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    alert('‚úÖ Added to chase list');
                    loadChaseList();
                } else {
                    alert('‚ùå Error: ' + (data.error || 'Failed to add'));
                }
            } catch (error) {
                alert('‚ùå Error: ' + error.message);
            }
        }

        // Add Alt Line function
        async function addAltLine(player, mainLine, altLine, statType, source) {
            try {
                const response = await fetch('/api/alt-lines', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        player: player,
                        main_line: mainLine,
                        alt_line: altLine,
                        stat_type: statType || 'PTS',
                        source: source || 'Manual'
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    alert('‚úÖ Alternative line added');
                    loadAltLines();
                } else {
                    alert('‚ùå Error: ' + (data.error || 'Failed to add'));
                }
            } catch (error) {
                alert('‚ùå Error: ' + error.message);
            }
        }

        // Pagination state
        let currentPage = 1;
        const itemsPerPage = 50;
        let allEdges = [];
        
        function generatePaginationHTML(totalPages, currentPage, startIdx, endIdx, totalItems) {
            if (totalPages <= 1) return '';
            
            let paginationHTML = '<div class="pagination">';
            
            // Previous button
            paginationHTML += `<button onclick="goToPage(${currentPage - 1})" class="page-btn" ${currentPage === 1 ? 'disabled' : ''}>‚Üê</button>`;
            
            // Page numbers with ellipsis for many pages
            const maxVisiblePages = 7;
            let startPage = 1;
            let endPage = totalPages;
            
            if (totalPages > maxVisiblePages) {
                const half = Math.floor(maxVisiblePages / 2);
                startPage = Math.max(1, currentPage - half);
                endPage = Math.min(totalPages, currentPage + half);
                
                if (endPage - startPage + 1 < maxVisiblePages) {
                    if (startPage === 1) {
                        endPage = Math.min(totalPages, maxVisiblePages);
                    } else {
                        startPage = Math.max(1, totalPages - maxVisiblePages + 1);
                    }
                }
            }
            
            // First page and ellipsis
            if (startPage > 1) {
                paginationHTML += `<button onclick="goToPage(1)" class="page-btn">1</button>`;
                if (startPage > 2) {
                    paginationHTML += `<span class="page-ellipsis">...</span>`;
                }
            }
            
            // Page numbers
            for (let i = startPage; i <= endPage; i++) {
                paginationHTML += `<button onclick="goToPage(${i})" class="page-btn ${i === currentPage ? 'active' : ''}">${i}</button>`;
            }
            
            // Last page and ellipsis
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    paginationHTML += `<span class="page-ellipsis">...</span>`;
                }
                paginationHTML += `<button onclick="goToPage(${totalPages})" class="page-btn">${totalPages}</button>`;
            }
            
            // Next button
            paginationHTML += `<button onclick="goToPage(${currentPage + 1})" class="page-btn" ${currentPage === totalPages ? 'disabled' : ''}>‚Üí</button>`;
            
            // Page info
            paginationHTML += `<span class="page-info">${startIdx + 1}-${Math.min(endIdx, totalItems)} of ${totalItems}</span>`;
            
            paginationHTML += '</div>';
            return paginationHTML;
        }
        
        function renderEdgesWithPagination(edges) {
            allEdges = edges;
            const totalPages = Math.ceil(edges.length / itemsPerPage);
            currentPage = Math.min(currentPage, totalPages || 1);
            
            const startIdx = (currentPage - 1) * itemsPerPage;
            const endIdx = startIdx + itemsPerPage;
            const pageEdges = edges.slice(startIdx, endIdx);
            
            const edgesContainer = document.getElementById('edgesContainer');
            const minProb = currentMinProbability || 70;
            const probLabel = minProb > 0 ? `${minProb}%+ PROBABILITY PROPS` : 'ALL EDGES';
            
            if (pageEdges.length > 0) {
                edgesContainer.innerHTML = `
                    <div class="edges-section">
                        <div class="section-header">
                            <h2>${probLabel} (<span id="edgeCount">${edges.length}</span>)</h2>
                        </div>
                        ${generatePaginationHTML(totalPages, currentPage, startIdx, endIdx, edges.length)}
                        <p class="section-subtitle">${minProb > 0 ? `Only showing props with ${minProb}%+ hit probability from all active NBA players` : 'Showing all edges'}</p>
                        <div class="edges-grid" id="edgesGrid">
                            ${pageEdges.map(edge => renderEdgeCard(edge)).join('')}
                        </div>
                        ${generatePaginationHTML(totalPages, currentPage, startIdx, endIdx, edges.length)}
                    </div>
                `;
            } else {
                edgesContainer.innerHTML = `
                    <div class="no-edges">
                        <p>No edges found with current threshold. Checked ${document.getElementById('totalPlayers')?.textContent || 0} players. Adjust threshold or check back later.</p>
                    </div>
                `;
            }
        }
        
        function renderEdgeCard(edge) {
            // Render confidence metrics
            const confidenceHTML = edge.confidence ? `
                <div class="confidence-meter">
                    <div class="confidence-grade grade-${edge.confidence.grade?.toLowerCase().replace('+', 'plus').replace('-', 'minus')}">${edge.confidence.grade}</div>
                    <div class="confidence-score">${Math.round(edge.confidence.confidence_score)}</div>
                </div>
                <div class="risk-badge risk-${edge.confidence.risk_tier?.toLowerCase()}">${edge.confidence.risk_tier}</div>
                <div class="stake-badge" title="Suggested: ${edge.confidence.suggested_stake_pct}% of bankroll">${edge.confidence.units}u</div>
            ` : (edge.ev ? `<div class="ev-badge ${edge.ev.is_positive_ev ? 'positive-ev' : 'negative-ev'}">EV: $${edge.ev.ev?.toFixed(2) || '0.00'}</div>` : '');
            
            // Render confidence details panel
            const confidenceDetailsHTML = edge.confidence ? `
                <div class="confidence-details">
                    <div class="confidence-row">
                        <span class="conf-label">Confidence:</span>
                        <span class="conf-value">${Math.round(edge.confidence.confidence_score)}/100 (${edge.confidence.grade_description})</span>
                    </div>
                    <div class="confidence-row">
                        <span class="conf-label">Risk Level:</span>
                        <span class="conf-value risk-text-${edge.confidence.risk_tier?.toLowerCase()}">${edge.confidence.risk_tier} - ${edge.confidence.risk_description}</span>
                    </div>
                    <div class="confidence-row">
                        <span class="conf-label">Suggested Stake:</span>
                        <span class="conf-value"><strong>${edge.confidence.suggested_stake_pct}%</strong> of bankroll (${edge.confidence.stake_label})</span>
                    </div>
                    ${edge.ev ? `
                    <div class="confidence-row">
                        <span class="conf-label">Expected Value:</span>
                        <span class="conf-value ${edge.ev.is_positive_ev ? 'ev-positive' : 'ev-negative'}">$${edge.ev.ev?.toFixed(2)} (${edge.ev.ev_percentage?.toFixed(1)}%)</span>
                    </div>
                    ` : ''}
                </div>
            ` : '';
            
            return `
                <div class="oracle-card ${edge.recommendation?.toLowerCase() || ''}">
                    <div class="oracle-header-row">
                        <div class="oracle-player">${edge.player || 'N/A'}</div>
                        ${confidenceHTML}
                    </div>
                    ${confidenceDetailsHTML}
                    ${edge.oracle ? `
                    <div class="oracle-content">
                        <div class="oracle-line"><strong>The Line:</strong> ${edge.oracle.verdict || edge.line || 'N/A'}</div>
                        <div class="oracle-sharp"><strong>The Sharp Angle:</strong> ${edge.oracle.sharp_angle || 'N/A'}</div>
                        <div class="oracle-key"><strong>Key Data Point:</strong> ${edge.oracle.key_data || 'N/A'}</div>
                        <div class="oracle-verdict"><strong>The Verdict:</strong> ${edge.oracle.verdict || 'N/A'}</div>
                    </div>
                    ` : `
                    <div class="edge-details">
                        <div class="stat-row"><span class="label">Line:</span><span class="value">${edge.line || 'N/A'}</span></div>
                        <div class="stat-row"><span class="label">L5 Avg:</span><span class="value">${edge.average || 'N/A'}</span></div>
                        <div class="recommendation"><strong>${edge.recommendation || 'N/A'}</strong></div>
                    </div>
                    `}
                    ${edge.streak && edge.streak.active ? renderStreakBadge(edge.streak) : ''}
                </div>
            `;
        }
        
        function renderStreakBadge(streak) {
            if (!streak || !streak.active) return '';
            
            const analytics = streak.analytics || {};
            const regression = analytics.regression || {};
            const evAdjustment = analytics.ev_adjustment || {};
            
            // Regression indicator
            const regressionMini = regression.risk_level ? 
                `<span class="regression-mini regression-${regression.risk_level}">${regression.risk_level.toUpperCase()}</span>` : '';
            
            // EV adjustment
            const evMini = evAdjustment.adjustment_pct !== undefined && evAdjustment.adjustment_pct !== 0 ? 
                `<div class="streak-ev-mini ${evAdjustment.adjustment_pct > 0 ? 'ev-positive' : 'ev-negative'}">
                    Streak EV: ${evAdjustment.adjustment_pct > 0 ? '+' : ''}${evAdjustment.adjustment_pct}%
                </div>` : '';
            
            return `
                <div class="streak-badge streak-${streak.streak_type?.toLowerCase() || 'over'}">
                    üî• ${streak.streak_count}-game ${streak.streak_type} streak
                    ${regressionMini}
                </div>
                ${evMini}
            `;
        }
        
        function renderStreakAnalytics(streak) {
            if (!streak || !streak.analytics) return '';
            
            const analytics = streak.analytics;
            const regression = analytics.regression || {};
            const historical = analytics.historical_patterns || {};
            const lineCorr = analytics.line_correlation || {};
            const evAdj = analytics.ev_adjustment || {};
            
            let html = '<div class="streak-analytics-panel">';
            
            // Regression Warning
            if (regression.risk_level) {
                const riskIcon = regression.risk_level === 'high' ? '‚ö†Ô∏è' : (regression.risk_level === 'medium' ? 'üü°' : 'üü¢');
                html += `
                    <div class="regression-indicator regression-${regression.risk_level}">
                        <div class="regression-header">${riskIcon} ${regression.risk_level.toUpperCase()} Regression Risk (${regression.risk_score || 0}%)</div>
                        ${regression.warnings && regression.warnings.length > 0 ? `
                            <div class="regression-warnings">
                                ${regression.warnings.slice(0, 3).map(w => `<div class="warning-item">‚Ä¢ ${w}</div>`).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }
            
            // Historical Performance
            if (historical.total_streaks_found !== undefined) {
                const avgStreak = streak.streak_type === 'OVER' ? historical.avg_over_streak_length : historical.avg_under_streak_length;
                const maxStreak = streak.streak_type === 'OVER' ? historical.max_over_streak : historical.max_under_streak;
                html += `
                    <div class="historical-patterns">
                        <div class="pattern-header">üìä Historical Patterns</div>
                        <div class="pattern-row"><span>Avg ${streak.streak_type} streak:</span><span>${avgStreak || 0} games</span></div>
                        <div class="pattern-row"><span>Max ${streak.streak_type} streak:</span><span>${maxStreak || 0} games</span></div>
                    </div>
                `;
            }
            
            // Line Correlation
            if (lineCorr.hit_rate_over !== undefined) {
                const hitRate = streak.streak_type === 'OVER' ? lineCorr.hit_rate_over : lineCorr.hit_rate_under;
                html += `
                    <div class="line-correlation">
                        <div class="correlation-header">üìà Line Correlation</div>
                        <div class="correlation-row"><span>Hit Rate (${streak.streak_type}):</span><span class="hit-rate">${hitRate || 0}%</span></div>
                        <div class="correlation-row"><span>Avg vs Line:</span><span>${lineCorr.avg_vs_line || 0}</span></div>
                        ${lineCorr.line_accuracy !== 'accurate' && lineCorr.line_suggestion ? `
                            <div class="line-suggestion">üí° ${lineCorr.line_suggestion}</div>
                        ` : ''}
                    </div>
                `;
            }
            
            // EV Adjustment
            if (evAdj.adjustment_pct !== undefined && evAdj.adjustment_pct !== 0) {
                html += `
                    <div class="ev-adjustment ${evAdj.adjustment_pct > 0 ? 'ev-positive' : 'ev-negative'}">
                        <div class="ev-header">Streak EV: ${evAdj.adjustment_pct > 0 ? '+' : ''}${evAdj.adjustment_pct}%</div>
                        ${evAdj.reasoning && evAdj.reasoning.length > 0 ? `
                            <div class="ev-reasons">
                                ${evAdj.reasoning.slice(0, 2).map(r => `<div class="ev-reason">${r}</div>`).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }
            
            html += '</div>';
            return html;
        }
        
        function goToPage(page) {
            const totalPages = Math.ceil(allEdges.length / itemsPerPage);
            if (page >= 1 && page <= totalPages) {
                currentPage = page;
                renderEdgesWithPagination(allEdges);
                // Scroll to top of edges container
                document.getElementById('edgesContainer')?.scrollIntoView({ behavior: 'smooth' });
            }
        }
        
        function previousPage() {
            goToPage(currentPage - 1);
        }
        
        function nextPage() {
            goToPage(currentPage + 1);
        }

        // Check loading status and show indicator if players are being loaded
        async function checkLoadingStatus() {
            const playerCount = parseInt(document.getElementById('totalPlayers')?.textContent || '0');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const loadingProgress = document.getElementById('loadingProgress');
            
            // Only check if no players are loaded yet
            if (playerCount === 0) {
                try {
                    const response = await fetch('/api/loading-status');
                    const data = await response.json();
                    
                    if (data.player_count > 0) {
                        // Players are now loaded! Refresh the page to show them
                        console.log(`Players loaded (${data.player_count}), refreshing page...`);
                        if (loadingIndicator) {
                            loadingIndicator.innerHTML = `
                                <div style="font-size: 28px; color: #00ff88; margin-bottom: 15px;">‚úÖ Players Loaded!</div>
                                <div style="font-size: 16px; color: #fff;">
                                    ${data.player_count} players ready. Refreshing page...
                                </div>
                            `;
                        }
                        setTimeout(() => window.location.reload(), 1500);
                        return;
                    }
                    
                    // Still loading - show indicator
                    if (loadingIndicator) {
                        loadingIndicator.style.display = 'block';
                    }
                    
                    if (data.loading_in_progress) {
                        // Update progress message
                        if (loadingProgress) {
                            const elapsed = data.elapsed_seconds || 0;
                            const mins = Math.floor(elapsed / 60);
                            const secs = elapsed % 60;
                            loadingProgress.textContent = `Loading in progress... (${mins}m ${secs}s elapsed)`;
                        }
                    } else {
                        // Not loading yet - will start on first request
                        if (loadingProgress) {
                            loadingProgress.textContent = 'Waiting for background load to start...';
                        }
                    }
                    
                    // Check again in 3 seconds
                    setTimeout(checkLoadingStatus, 3000);
                    
                } catch (error) {
                    console.error('Error checking loading status:', error);
                    // Still check again even if error
                    setTimeout(checkLoadingStatus, 5000);
                }
            } else {
                // Players are loaded, hide indicator
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'none';
                }
            }
        }

        // Initial load timestamp
        document.addEventListener('DOMContentLoaded', function() {
            try {
                const now = new Date().toLocaleString();
                const lastUpdateEl = document.getElementById('lastUpdate');
                if (lastUpdateEl) lastUpdateEl.textContent = `Last updated: ${now}`;
                
                // Load daily status (wrapped in try-catch)
                try {
                    if (typeof loadDailyUpdateStatus === 'function') loadDailyUpdateStatus();
                } catch (e) { console.error('Error loading daily status:', e); }
                
                // Check loading status immediately if no players loaded
                try {
                    if (typeof checkLoadingStatus === 'function') checkLoadingStatus();
                } catch (e) { console.error('Error checking loading status:', e); }
                
                // Refresh status every minute
                setInterval(() => {
                    try {
                        if (typeof loadDailyUpdateStatus === 'function') loadDailyUpdateStatus();
                    } catch (e) { console.error('Error in status interval:', e); }
                }, 60000);
                
                // Track player count to detect when new players are loaded
                let lastPlayerCount = {{ projections|length if projections else 0 }};
                
                // Auto-refresh edges every 15 seconds to catch background updates faster
                // This ensures newly loaded players appear quickly
                setInterval(() => {
                    try {
                        if (typeof refreshData === 'function') {
                            refreshData().then((data) => {
                                // Check if player count increased (new players loaded)
                                const currentCount = data?.total_players_loaded || data?.projections_count || parseInt(document.getElementById('totalPlayers')?.textContent || '0');
                                if (currentCount > lastPlayerCount && lastPlayerCount >= 0) {
                                    const newPlayers = currentCount - lastPlayerCount;
                                    console.log(`New players detected! Count increased from ${lastPlayerCount} to ${currentCount}`);
                                    lastPlayerCount = currentCount;
                                    // Show a notification
                                    const notification = document.createElement('div');
                                    notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #27ae60; color: white; padding: 15px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); font-weight: bold; font-size: 14px;';
                                    notification.textContent = `${newPlayers} new player${newPlayers > 1 ? 's' : ''} loaded!`;
                                    document.body.appendChild(notification);
                                    setTimeout(() => notification.remove(), 5000);
                                } else if (currentCount !== lastPlayerCount) {
                                    lastPlayerCount = currentCount;
                                }
                            }).catch(err => {
                                console.error('Error refreshing:', err);
                            });
                        }
                    } catch (e) { console.error('Error in refresh interval:', e); }
                }, 15000); // Reduced to 15 seconds for faster updates
                
                // Load glitched props scan status (wrapped in try-catch)
                try {
                    if (typeof loadGlitchedProps === 'function') loadGlitchedProps();
                    if (typeof loadGlitchedScanStatus === 'function') loadGlitchedScanStatus();
                } catch (e) { console.error('Error loading glitched props:', e); }
                
                // Refresh scan status every 5 minutes
                setInterval(() => {
                    try {
                        if (typeof loadGlitchedScanStatus === 'function') loadGlitchedScanStatus();
                    } catch (e) { console.error('Error in scan status interval:', e); }
                }, 300000);
                
                console.log('Page initialized successfully');
            } catch (e) {
                console.error('Error during page initialization:', e);
            }
        });

        // Glitched Props Functions
        async function triggerGlitchedScan() {
            const btn = document.querySelector('.btn-scan-glitch');
            const statusText = document.getElementById('scanStatusText');
            
            if (!btn) return;
            
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = '‚ö° Scanning... (Instant)';
            
            if (statusText) {
                statusText.textContent = '‚ö° Running quick scan for instant results...';
                statusText.style.color = '#ffd700';
            }
            
            try {
                const response = await fetch('/api/glitched-props/scan', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'}
                });
                
                const data = await response.json();
                
                if (data.success) {
                    btn.textContent = '‚úÖ Scan Complete!';
                    if (statusText) {
                        statusText.textContent = `‚úÖ Quick scan complete! Found ${data.found_count} new glitched props.`;
                        statusText.style.color = '#00ff88';
                    }
                    
                    // Reload glitched props table
                    loadGlitchedProps();
                    
                    // Show success message
                    if (data.found_count > 0) {
                        alert(`‚úÖ Found ${data.found_count} new glitched props!\n\n${data.message}`);
                    } else {
                        alert(`‚úÖ Quick scan complete!\n\nNo new glitched props found this scan.`);
                    }
                    
                    // Reset button after 3 seconds
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }, 3000);
                } else {
                    btn.textContent = '‚ùå Error';
                    if (statusText) {
                        statusText.textContent = `‚ùå Error: ${data.error || 'Scan failed'}`;
                        statusText.style.color = '#ff4444';
                    }
                    alert('‚ùå Error: ' + (data.error || 'Scan failed'));
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }, 3000);
                }
            } catch (error) {
                btn.textContent = '‚ùå Error';
                if (statusText) {
                    statusText.textContent = `‚ùå Error: ${error.message}`;
                    statusText.style.color = '#ff4444';
                }
                alert('‚ùå Error: ' + error.message);
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 3000);
            }
        }

        // Format relative time (e.g., "5m ago", "2h ago", "1d ago")
        function formatRelativeTime(dateStr) {
            if (!dateStr) return 'N/A';
            try {
                const date = new Date(dateStr.replace(' ', 'T'));
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                
                if (diffMins < 1) return 'Just now';
                if (diffMins < 60) return `${diffMins}m ago`;
                
                const diffHours = Math.floor(diffMins / 60);
                if (diffHours < 24) return `${diffHours}h ago`;
                
                const diffDays = Math.floor(diffHours / 24);
                return `${diffDays}d ago`;
            } catch (e) {
                return dateStr;
            }
        }
        
        // Get status badge HTML based on validation
        function getStatusBadge(validation) {
            if (!validation) {
                return '<span class="status-badge status-unknown">? Unknown</span>';
            }
            if (!validation.is_valid) {
                const warnings = validation.warnings ? validation.warnings.join(', ') : 'Invalid data';
                return `<span class="status-badge status-invalid" title="${warnings}">‚ö†Ô∏è Invalid</span>`;
            }
            if (validation.staleness_level === 'stale') {
                return '<span class="status-badge status-stale" title="Data is over 24 hours old">üî¥ Stale</span>';
            }
            if (validation.staleness_level === 'warning') {
                return '<span class="status-badge status-warning" title="Data is over 6 hours old">üü° Aging</span>';
            }
            return '<span class="status-badge status-fresh">üü¢ Fresh</span>';
        }
        
        // Get source badge HTML
        function getSourceBadge(source, sourceDetail) {
            const sourceName = sourceDetail || source || 'Manual';
            const sourceClass = source || 'manual';
            return `<span class="source-badge source-${sourceClass}">${sourceName}</span>`;
        }
        
        // Get row class based on staleness
        function getRowClass(validation) {
            if (!validation) return '';
            if (validation.staleness_level === 'stale') return 'row-stale';
            if (validation.staleness_level === 'warning') return 'row-warning';
            return '';
        }

        async function loadGlitchedProps() {
            try {
                const response = await fetch('/api/glitched-props');
                const data = await response.json();
                const tbody = document.getElementById('glitchedPropsTableBody');
                
                if (!tbody) return;
                
                if (data.props && data.props.length > 0) {
                    tbody.innerHTML = data.props.map(prop => `
                        <tr data-id="${prop.id}" class="${getRowClass(prop.validation)}">
                            <td>${prop.prop || 'N/A'}</td>
                            <td>${getSourceBadge(prop.source, prop.source_detail)}</td>
                            <td>${prop.reasoning || 'N/A'}</td>
                            <td>
                                <span class="rating-badge rating-${prop.rating}">
                                    ${prop.rating}/10
                                </span>
                            </td>
                            <td>${prop.platform || 'N/A'}</td>
                            <td class="timestamp-cell" title="${prop.updated_at || prop.created_at || ''}">${formatRelativeTime(prop.updated_at || prop.created_at)}</td>
                            <td>${getStatusBadge(prop.validation)}</td>
                            <td>
                                <button onclick="editGlitchedProp(${prop.id})" class="btn-edit">‚úèÔ∏è</button>
                                <button onclick="deleteGlitchedProp(${prop.id})" class="btn-delete">üóëÔ∏è</button>
                            </td>
                        </tr>
                    `).join('');
                } else {
                    tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 20px; color: #888;">No glitched props found</td></tr>';
                }
            } catch (error) {
                console.error('Error loading glitched props:', error);
            }
        }

        async function loadGlitchedScanStatus() {
            try {
                const response = await fetch('/api/glitched-props/status');
                const data = await response.json();
                const statusText = document.getElementById('scanStatusText');
                const scanBtn = document.querySelector('.btn-scan-glitch');
                const statusBar = document.getElementById('glitchedScanStatus');
                
                if (!statusText) return;
                
                if (data.last_scan) {
                    const lastScan = new Date(data.last_scan.replace(' ', 'T'));
                    const now = new Date();
                    const minsAgo = Math.floor((now - lastScan) / (1000 * 60));
                    const hoursAgo = minsAgo / 60;
                    
                    // Update status bar based on staleness
                    if (hoursAgo >= 1) {
                        // Data is stale (over 1 hour)
                        statusText.innerHTML = `‚ö†Ô∏è <strong>DATA STALE!</strong> Last scan: ${minsAgo} min ago | ${data.total_scanned} players, ${data.glitches_found} glitches | <strong>Click "Run Scan Now" to refresh</strong>`;
                        statusText.style.color = '#e74c3c';
                        if (statusBar) {
                            statusBar.classList.add('status-bar-stale');
                            statusBar.classList.remove('status-bar-warning', 'status-bar-fresh');
                        }
                        if (scanBtn) {
                            scanBtn.classList.add('btn-pulse-warning');
                            scanBtn.textContent = '‚ö†Ô∏è Refresh Stale Data!';
                        }
                    } else if (minsAgo >= 15) {
                        // Data is aging (over 15 minutes)
                        statusText.innerHTML = `üü° Data aging: ${minsAgo} min since last scan | ${data.total_scanned} players, ${data.glitches_found} glitches | Next scan in ~${Math.max(0, data.scan_interval_minutes - (minsAgo % data.scan_interval_minutes))} min`;
                        statusText.style.color = '#f39c12';
                        if (statusBar) {
                            statusBar.classList.add('status-bar-warning');
                            statusBar.classList.remove('status-bar-stale', 'status-bar-fresh');
                        }
                        if (scanBtn) {
                            scanBtn.classList.remove('btn-pulse-warning');
                            scanBtn.textContent = 'üîç Run Scan Now';
                        }
                    } else {
                        // Data is fresh
                        statusText.innerHTML = `üü¢ Fresh data: ${data.total_scanned} players scanned, ${data.glitches_found} glitches found | Last scan: ${minsAgo} min ago | Next auto-scan in ~${Math.max(0, data.scan_interval_minutes - minsAgo)} min`;
                        statusText.style.color = '#27ae60';
                        if (statusBar) {
                            statusBar.classList.add('status-bar-fresh');
                            statusBar.classList.remove('status-bar-stale', 'status-bar-warning');
                        }
                        if (scanBtn) {
                            scanBtn.classList.remove('btn-pulse-warning');
                            scanBtn.textContent = 'üîç Run Scan Now';
                        }
                    }
                } else {
                    statusText.innerHTML = '‚è≥ Background scanning starting... (runs every 5 minutes)';
                    statusText.style.color = '#888';
                    if (statusBar) {
                        statusBar.classList.remove('status-bar-stale', 'status-bar-warning', 'status-bar-fresh');
                    }
                }
            } catch (error) {
                console.error('Error loading scan status:', error);
                const statusText = document.getElementById('scanStatusText');
                if (statusText) {
                    statusText.innerHTML = '‚ùå Error loading scan status';
                    statusText.style.color = '#e74c3c';
                }
            }
        }
    </script>
    <script src="{{ url_for('static', filename='parlay_ui.js') }}"></script>
</body>
</html>
